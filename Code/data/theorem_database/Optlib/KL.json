[
    {
        "theorem_name": "limsubdifferential_Graph",
        "theorem_statement": " (f : E â†’ â„)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "def limsubdifferential_Graph (f : E â†’ â„) :=\n  {(x, fx, u) : E Ã— â„ Ã— E | fx = f x âˆ§ u âˆˆ f_subdifferential f x}",
        "type": "definition",
        "filename": "KL"
    },
    {
        "theorem_name": "subdifferential_Graph",
        "theorem_statement": " (f : E â†’ â„)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "def subdifferential_Graph (f : E â†’ â„) :=\n  {(x, u) : E Ã— E | u âˆˆ subdifferential f x}",
        "type": "definition",
        "filename": "KL"
    },
    {
        "theorem_name": "subdifferential_Graph'",
        "theorem_statement": " (f : E â†’ â„) : subdifferential_Graph f = {(x, u) : E Ã— E | (x, f x, u) âˆˆ closure (limsubdifferential_Graph f)}",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem subdifferential_Graph' (f : E â†’ â„) :\n    subdifferential_Graph f = {(x, u) : E Ã— E | (x, f x, u) âˆˆ closure (limsubdifferential_Graph f)} :=\n  by\n  ext y\n  constructor\n  Â· intro hy\n    simp [subdifferential_Graph, subdifferential] at hy\n    simp [mem_closure_iff_seq_limit, limsubdifferential_Graph]\n    rcases hy with âŸ¨u, âŸ¨u_conv, âŸ¨fun_conv, âŸ¨v, hvâŸ©âŸ©âŸ©âŸ©\n    use fun n => (u n, f (u n), v n)\n    constructor\n    Â· intro n; simp; exact (hv n).1\n    Â· apply Tendsto.prod_mk_nhds u_conv (Tendsto.prod_mk_nhds fun_conv ((forall_and_right _ _).1 hv).2)\n  Â· intro h\n    simp [subdifferential_Graph, subdifferential]\n    simp at h\n    obtain exist_seq := mem_closure_iff_seq_limit.1 h\n    rcases exist_seq with âŸ¨x, âŸ¨exist_seqâ‚, x_convergeâŸ©âŸ©\n    rw [nhds_prod_eq] at x_converge\n    obtain âŸ¨x1_conv, x2_convâŸ© := (Filter.tendsto_prod_iff'.1 x_converge)\n    rw [nhds_prod_eq] at x2_conv\n    obtain âŸ¨fx1_conv, x2_conv'âŸ© := (Filter.tendsto_prod_iff'.1 x2_conv)\n    simp [limsubdifferential_Graph] at exist_seqâ‚\n    use (fun n => (x n).1)\n    constructor; exact x1_conv\n    constructor\n    have : (fun n â†¦ (x n).2.1) = (fun n => f (x n).1) := by ext n; exact (exist_seqâ‚ n).1\n    rwa [this] at fx1_conv\n    use (fun n => (x n).2.2)\n    intro n; exact âŸ¨(exist_seqâ‚ n).2, x2_conv'âŸ©",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "GraphOfSubgradientIsClosed",
        "theorem_statement": " {f : E â†’ â„} {xn un : â„• â†’ E} {x u : E} (hx : âˆ€ n, (xn n, un n) âˆˆ subdifferential_Graph f)\n  (hconv : Tendsto (fun n => (xn n, un n)) atTop (ğ“ (x, u))) (hf : Tendsto (fun n => f (xn n)) atTop (ğ“ (f x))) :\n  (x, u) âˆˆ subdifferential_Graph f",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem GraphOfSubgradientIsClosed {f : E â†’ â„} {xn un : â„• â†’ E} {x u : E}\n    (hx : âˆ€ n, (xn n, un n) âˆˆ subdifferential_Graph f) (hconv : Tendsto (fun n => (xn n, un n)) atTop (ğ“ (x, u)))\n    (hf : Tendsto (fun n => f (xn n)) atTop (ğ“ (f x))) : (x, u) âˆˆ subdifferential_Graph f :=\n  by\n  rw [subdifferential_Graph', mem_setOf_eq]\n  simp only\n  rw [â† closure_closure, mem_closure_iff_seq_limit]\n  use fun n => (xn n, f (xn n), un n)\n  constructor\n  Â· intro n\n    have := hx n\n    rw [subdifferential_Graph', mem_setOf_eq] at this\n    exact this\n  rw [nhds_prod_eq, Filter.tendsto_prod_iff'] at hconv; simp at hconv\n  exact\n    Tendsto.prod_mk_nhds hconv.1\n      (Tendsto.prod_mk_nhds hf hconv.2)\n        /- Definition of Î¦_Î·, the family of desingularizing function -/",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "desingularizing_function",
        "theorem_statement": " (Î· : â„)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "def desingularizing_function (Î· : â„) :=\n  {Ï† : â„ â†’ â„ |\n    (ConcaveOn â„ (Ico 0 Î·) Ï†)\n        -- âˆ§ (âˆ€ x âˆˆ Ioo 0 Î·, Ï† x > 0) âˆ§\n      (Ï† 0 = 0) âˆ§ (ContDiffOn â„ 1 Ï† (Ioo 0 Î·)) âˆ§ (ContinuousAt Ï† 0) âˆ§ (âˆ€ x âˆˆ Ioo 0 Î·, deriv Ï† x > 0)}",
        "type": "definition",
        "filename": "KL"
    },
    {
        "theorem_name": "desingularizing_function_is_nonneg",
        "theorem_statement": " (Ï† : â„ â†’ â„) (Î· : â„) (h : Ï† âˆˆ desingularizing_function Î·) : âˆ€ x âˆˆ Ioo 0 Î·, Ï† x > 0",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem desingularizing_function_is_nonneg (Ï† : â„ â†’ â„) (Î· : â„) (h : Ï† âˆˆ desingularizing_function Î·) :\n    âˆ€ x âˆˆ Ioo 0 Î·, Ï† x > 0 := by\n  simp [desingularizing_function] at h\n  intro x âŸ¨hxâ‚, hxâ‚‚âŸ©\n  rcases h with âŸ¨_, hâ‚‚, hâ‚ƒ, hâ‚„, hâ‚…âŸ©\n  have Cont_Ï† : ContinuousOn Ï† (Icc 0 x) := by\n    apply ContinuousAt.continuousOn\n    intro y hy\n    by_cases hy0 : y = 0\n    rwa [hy0]\n    push_neg at hy0\n    have cont_Ï† := ContDiffOn.continuousOn hâ‚ƒ\n    have isopen : IsOpen (Ioo 0 Î·) := isOpen_Ioo\n    by_cases hyx : y = x\n    Â· simp [hyx]\n      apply (IsOpen.continuousOn_iff isopen).1 cont_Ï†\n      exact âŸ¨hxâ‚, hxâ‚‚âŸ©\n    Â· push_neg at hyx\n      have hy2 : y âˆˆ Ioo 0 x := âŸ¨lt_of_le_of_ne hy.1 (id (Ne.symm hy0)), lt_of_le_of_ne hy.2 hyxâŸ©\n      apply (IsOpen.continuousOn_iff isopen).1 cont_Ï†\n      use hy2.1\n      rcases hy2 with âŸ¨_, hy2âŸ©\n      linarith\n  have Diff_Ï† : DifferentiableOn â„ Ï† (Ioo 0 x) :=\n    by\n    have diff_Ï† := ContDiffOn.differentiableOn hâ‚ƒ (by simp)\n    have subIoo : (Ioo 0 x) âŠ† (Ioo 0 Î·) := by intro x hx; simp at hx; use hx.1; linarith\n    exact DifferentiableOn.mono diff_Ï† subIoo\n  have hhh : âˆƒ y âˆˆ Ioo 0 x, Ï† x = Ï† 0 + (deriv Ï† y) * (x - 0) :=\n    by\n    obtain h_lag := exists_deriv_eq_slope Ï† hxâ‚ Cont_Ï† Diff_Ï†\n    rcases h_lag with âŸ¨c, âŸ¨hc, hvalâŸ©âŸ©\n    use c, hc\n    field_simp [hval]\n  choose y hyâ‚ hyâ‚‚ using hhh\n  simp [hyâ‚‚, hâ‚‚]; field_simp; rcases hyâ‚ with âŸ¨hyâ‚, hyâ‚'âŸ©\n  have yleq : y < Î· := by linarith\n  exact hâ‚… y hyâ‚ yleq",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "KL_point_with_reparameter",
        "theorem_statement": " (Ïƒ : E â†’ â„) (u : E) (Ï† : â„ â†’ â„) : Prop",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "def KL_point_with_reparameter (Ïƒ : E â†’ â„) (u : E) (Ï† : â„ â†’ â„) : Prop :=\n  âˆƒ Î· âˆˆ Ioi 0,\n    âˆƒ s âˆˆ ğ“ u,\n      (Ï† âˆˆ desingularizing_function Î·) âˆ§\n        (âˆ€ x âˆˆ s âˆ© {y âˆˆ active_domain Ïƒ | Ïƒ u < Ïƒ y âˆ§ Ïƒ y < Ïƒ u + Î·},\n          deriv Ï† (Ïƒ x - Ïƒ u) * (EMetric.infEdist 0 (subdifferential Ïƒ x)).toReal â‰¥ 1)\n          -- Definition of the KL property at one point",
        "type": "definition",
        "filename": "KL"
    },
    {
        "theorem_name": "KL_point",
        "theorem_statement": " (f : E â†’ â„) (u : E) : Prop",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "def KL_point (f : E â†’ â„) (u : E) : Prop :=\n  âˆƒ Î· âˆˆ Ioi 0,\n    âˆƒ s âˆˆ ğ“ u,\n      âˆƒ Ï† âˆˆ desingularizing_function Î·,\n        âˆ€ x âˆˆ s âˆ© {y | f u < f y âˆ§ f y < f u + Î·},\n          (ENNReal.ofReal (deriv Ï† (f x - f u))) * (EMetric.infEdist 0 (subdifferential f x)) â‰¥\n            ENNReal.ofReal\n              1\n                -- Definition of the KL function",
        "type": "definition",
        "filename": "KL"
    },
    {
        "theorem_name": "KL_function",
        "theorem_statement": " (f : E â†’ â„) : Prop",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "def KL_function (f : E â†’ â„) : Prop :=\n  âˆ€ u âˆˆ active_domain f, KL_point f u",
        "type": "definition",
        "filename": "KL"
    },
    {
        "theorem_name": "KL_property_with_regularization",
        "theorem_statement": " (f : E â†’ â„) (u' : E) (Ï† : â„ â†’ â„) : Prop",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "def KL_property_with_regularization (f : E â†’ â„) (u' : E) (Ï† : â„ â†’ â„) : Prop :=\n  âˆƒ Î· âˆˆ Ioi 0,\n    âˆƒ s âˆˆ ğ“ u',\n      (Ï† âˆˆ desingularizing_function Î·) âˆ§\n        (âˆ€ x âˆˆ s âˆ© {y âˆˆ active_domain f | f u' < f y âˆ§ f y < f u' + Î·},\n          (EMetric.infEdist 0 (subdifferential (Î» u => Ï† (f u - f u')) x)).toReal â‰¥ 1)\n          -- deriv of function (fun t => câ»Â¹ * t) is câ»Â¹",
        "type": "definition",
        "filename": "KL"
    },
    {
        "theorem_name": "deriv_of_const_mul_func",
        "theorem_statement": " (x : â„) : deriv (fun (t : â„) => câ»Â¹ * t) x = câ»Â¹",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem deriv_of_const_mul_func (x : â„) : deriv (fun (t : â„) => câ»Â¹ * t) x = câ»Â¹ :=\n  by\n  apply HasDerivAt.deriv\n  have : (fun (t : â„) => câ»Â¹ * t) = (fun t => t * câ»Â¹) := by ext t; ring\n  rw [this]\n  apply\n    hasDerivAt_mul_const\n      câ»Â¹\n        -- Function (fun t => câ»Â¹ * t) is a desingularizing function",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "const_mul_special_concave",
        "theorem_statement": " : âˆ€ c > 0, (fun t => câ»Â¹ * t) âˆˆ desingularizing_function (c / 2)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem const_mul_special_concave : âˆ€ c > 0, (fun t => câ»Â¹ * t) âˆˆ desingularizing_function (c / 2) :=\n  by\n  intro c cpos; let Ï† := (fun t => câ»Â¹ * t)\n  simp [desingularizing_function]\n  have fun_smul_eq_mul : (fun t â†¦ câ»Â¹ * t) = (fun t â†¦ câ»Â¹ â€¢ t) := by ext t; rw [smul_eq_mul]\n  have hâ‚ : ConcaveOn â„ (Ico 0 (c / 2)) Ï† := by\n    rw [ConcaveOn]; constructor; apply convex_Ico\n    intro x _ y _ a b _ _ _\n    show a â€¢ (câ»Â¹ * x) + b â€¢ (câ»Â¹ * y) â‰¤ câ»Â¹ * (a â€¢ x + b â€¢ y)\n    rw [â† smul_mul_assoc, â† smul_mul_assoc]; repeat rw [smul_eq_mul]\n    linarith\n      -- have hâ‚‚: âˆ€ (x : â„), 0 < x â†’ x < c / 2 â†’ 0 < Ï† x := by\n        --   intro x xpos _; show câ»Â¹ * x > 0; field_simp; exact cpos\n  have hâ‚ƒ : ContDiffOn â„ 1 (fun t â†¦ câ»Â¹ * t) (Ioo 0 (c / 2)) := by rw [fun_smul_eq_mul]; apply ContDiff.contDiffOn;\n    apply contDiff_const_smul\n  have hâ‚„ : ContinuousAt (fun t â†¦ câ»Â¹ * t) 0 := by\n    rw [fun_smul_eq_mul]; apply (continuousAt_const_smul_iffâ‚€ _).2\n    apply continuousAt_id; field_simp\n  have hâ‚… : âˆ€ (x : â„), 0 < x â†’ x < c / 2 â†’ 0 < deriv (fun t â†¦ câ»Â¹ * t) x := by intro x _ _;\n    rw [deriv_of_const_mul_func]; field_simp; exact cpos\n  exact\n    âŸ¨hâ‚, hâ‚ƒ, hâ‚„, hâ‚…âŸ©\n      -- Type transformation: ENNReal.ofReal (1 / (â†‘n + 1)) = (1 / (â†‘n + 1))",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "one_div_type_trans",
        "theorem_statement": " : âˆ€ n : â„•, ENNReal.ofReal (1 / (â†‘n + 1)) = (1 / (â†‘n + 1))",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem one_div_type_trans : âˆ€ n : â„•, ENNReal.ofReal (1 / (â†‘n + 1)) = (1 / (â†‘n + 1)) :=\n  by\n  intro n\n  have : ENNReal.ofReal (1 / (â†‘n + 1)) = ENNReal.ofReal 1 / ENNReal.ofReal (â†‘n + 1) :=\n    by\n    apply ENNReal.ofReal_div_of_pos\n    exact Nat.cast_add_one_pos n\n  rw [this, ENNReal.ofReal_one]\n  simp only [one_div, inv_inj]\n  rw [â† ENNReal.ofReal_one]\n  have : â†‘n = ENNReal.ofReal (â†‘n) := Eq.symm (ENNReal.ofReal_natCast n)\n  rw [this]\n  refine ENNReal.ofReal_add ?hp ?hq\n  exact Nat.cast_nonneg' n\n  exact zero_le_one' â„",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "const_mul_edist_ge_one",
        "theorem_statement": " {c : â„} {ed : ENNReal} (hpos : c > 0) (hed : ed â‰¥ ENNReal.ofReal c) : ENNReal.ofReal câ»Â¹ * ed â‰¥ ENNReal.ofReal 1",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem const_mul_edist_ge_one {c : â„} {ed : ENNReal} (hpos : c > 0) (hed : ed â‰¥ ENNReal.ofReal c) :\n    ENNReal.ofReal câ»Â¹ * ed â‰¥ ENNReal.ofReal 1 :=\n  by\n  by_cases hed' : ed = âŠ¤\n  have : ENNReal.ofReal câ»Â¹ * ed = âŠ¤ := by rw [hed']; refine ENNReal.mul_top ?h; simpa\n  rw [this]; simp; push_neg at hed'\n  calc\n    _ â‰¥ ENNReal.ofReal câ»Â¹ * ENNReal.ofReal c := mul_le_mul_left' hed (ENNReal.ofReal câ»Â¹)\n    _ = ENNReal.ofReal 1 := by rw [â† ENNReal.ofReal_mul]; field_simp; simp; exact le_of_lt hpos",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "edist_geq_const",
        "theorem_statement": " (h_noncrit : 0 âˆ‰ subdifferential f x) :\n  âˆƒ c > 0, âˆ€ u, â€–u - xâ€– + â€–f u - f xâ€– < c â†’ EMetric.infEdist 0 (subdifferential f u) â‰¥ ENNReal.ofReal c",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem edist_geq_const (h_noncrit : 0 âˆ‰ subdifferential f x) :\n    âˆƒ c > 0, âˆ€ u, â€–u - xâ€– + â€–f u - f xâ€– < c â†’ EMetric.infEdist 0 (subdifferential f u) â‰¥ ENNReal.ofReal c :=\n  by\n  by_contra! hc\n  have sqh :\n    âˆ€ n : â„•,\n      âˆƒ u,\n        â€–u - xâ€– + â€–f u - f xâ€– < 1 / (n + 1) âˆ§\n          (EMetric.infEdist 0 (subdifferential f u)) < ENNReal.ofReal (1 / (n + 1)) :=\n    fun n â†¦ hc (1 / (n + 1)) (by simp; linarith)\n  choose u hu using sqh\n  have inequ_fun : âˆ€ n, (EMetric.infEdist 0 (subdifferential f (u n))).toReal â‰¤ 1 / (n + 1) :=\n    by\n    intro n\n    apply (ENNReal.toReal_le_of_le_ofReal _ (le_of_lt (hu n).right))\n    simp; linarith\n  have : Tendsto (fun n â†¦ (EMetric.infEdist 0 (subdifferential f (u n))).toReal) atTop (ğ“ 0) :=\n    squeeze_zero (by simp) inequ_fun tendsto_one_div_add_atTop_nhds_zero_nat\n  have h_contra : 0 âˆˆ subdifferential f x :=\n    by\n    have u_to_x : Tendsto u atTop (ğ“ x) :=\n      by\n      have : Tendsto (fun n => â€–u n - xâ€–) atTop (ğ“ 0) :=\n        by\n        apply squeeze_zero (by simp) _ tendsto_one_div_add_atTop_nhds_zero_nat\n        intro n\n        have inequâ‚ : â€–u n - xâ€– â‰¤ 1 / (n + 1) := by\n          rcases hu n with âŸ¨huâ‚, _âŸ©\n          apply (le_of_add_le_of_nonneg_left (le_of_lt huâ‚) (norm_nonneg (f (u n) - f x)))\n        exact inequâ‚\n      apply tendsto_iff_norm_sub_tendsto_zero.2 this\n    have fu_to_fx : Tendsto (fun n â†¦ f (u n)) atTop (ğ“ (f x)) :=\n      by\n      have : Tendsto (fun n => â€–f (u n) - f xâ€–) atTop (ğ“ 0) :=\n        by\n        apply squeeze_zero (by simp) _ tendsto_one_div_add_atTop_nhds_zero_nat\n        intro n\n        have inequâ‚‚ : â€–f (u n) - f xâ€– â‰¤ 1 / (n + 1) :=\n          by\n          rcases hu n with âŸ¨huâ‚, _âŸ©\n          apply (le_of_add_le_of_nonneg_right (le_of_lt huâ‚) (norm_nonneg (u n - x)))\n        exact inequâ‚‚\n      apply tendsto_iff_norm_sub_tendsto_zero.2 this\n    have exist_v : âˆ€ n : â„•, âˆƒ vn, vn âˆˆ subdifferential f (u n) âˆ§ dist 0 vn < 1 / (n + 1) :=\n      by\n      intro n\n      rcases hu n with âŸ¨_, huâ‚‚âŸ©\n      have : âˆƒ vn âˆˆ subdifferential f (u n), edist 0 vn < 1 / (n + 1) :=\n        by\n        apply EMetric.infEdist_lt_iff.1\n        rw [â† one_div_type_trans n]\n        exact huâ‚‚\n      choose vn hvn using this\n      use vn, hvn.left\n      rw [â† one_div_type_trans n] at hvn\n      apply edist_lt_ofReal.1 hvn.right\n    choose v hv using exist_v\n    have v_in_subdiff : âˆ€ n : â„•, (u n, v n) âˆˆ subdifferential_Graph f :=\n      by\n      intro n\n      exact (hv n).1\n    have v_to_zero : Tendsto v atTop (ğ“ 0) := by\n      rw [dist_zero_left] at hv\n      have : Tendsto (fun n => â€–v nâ€–) atTop (ğ“ 0) :=\n        by\n        apply squeeze_zero (by simp) _ tendsto_one_div_add_atTop_nhds_zero_nat\n        intro n\n        apply le_of_lt (hv n).right\n      apply tendsto_zero_iff_norm_tendsto_zero.2 this\n    show (x, 0) âˆˆ subdifferential_Graph f\n    apply GraphOfSubgradientIsClosed v_in_subdiff (Filter.Tendsto.prod_mk_nhds u_to_x v_to_zero) fu_to_fx\n  contradiction",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "KL_property_at_noncritical_point",
        "theorem_statement": " (h_noncrit : 0 âˆ‰ subdifferential f x) : KL_point f x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace â„ E]",
            "variable {f : E â†’ â„}",
            "variable {x : E}"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "/-- Non-critical KL property is naturally true -/\ntheorem KL_property_at_noncritical_point (h_noncrit : 0 âˆ‰ subdifferential f x) : KL_point f x :=\n  by\n  obtain âŸ¨c, hc_pos, hâŸ© := edist_geq_const h_noncrit\n  let Ï† := (fun (t : â„) => câ»Â¹ * t)\n  rw [KL_point]\n  use c / 2, (by simpa using hc_pos), Metric.ball x (c / 2)\n  constructor\n  apply Metric.ball_mem_nhds; simpa using hc_pos\n  use Ï†, const_mul_special_concave c hc_pos\n  intro u hu\n  rw [deriv_of_const_mul_func (f u - f x)]\n  have : â€–u - xâ€– + â€–f u - f xâ€– < c := by\n    rw [â† add_halves c]\n    apply add_lt_add\n    Â· apply mem_ball_iff_norm.1 hu.left\n    Â· simp at *\n      rw [abs_eq_self.2] <;> linarith\n  exact const_mul_edist_ge_one hc_pos (h u this)",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "real_geq_ennreal_ofreal_geq",
        "theorem_statement": " {a b : â„} {c : ENNReal} (hgeq : a â‰¥ b) (apos : a > 0) : (ENNReal.ofReal a) * c â‰¥ (ENNReal.ofReal b) * c",
        "variable": [],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem real_geq_ennreal_ofreal_geq {a b : â„} {c : ENNReal} (hgeq : a â‰¥ b) (apos : a > 0) :\n    (ENNReal.ofReal a) * c â‰¥ (ENNReal.ofReal b) * c :=\n  by\n  by_cases hc : c = 0\n  rw [hc]\n  simp\n  push_neg at hc\n  by_cases hctop : c = âŠ¤\n  rw [hctop]\n  have ha : (ENNReal.ofReal a) * âŠ¤ = âŠ¤ := by\n    refine ENNReal.mul_top ?h\n    simpa\n  rw [ha]\n  simp\n  push_neg at hctop\n  refine (ENNReal.mul_le_mul_right ?_ ?_).mpr ?_\n  Â· exact hc\n  Â· exact hctop\n  Â· exact ENNReal.ofReal_le_ofReal hgeq",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "is_constant_on",
        "theorem_statement": " (f : E â†’ â„) (Î© : Set E) : Prop",
        "variable": [],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "def is_constant_on (f : E â†’ â„) (Î© : Set E) : Prop :=\n  âˆ€ x âˆˆ Î©, âˆ€ y âˆˆ Î©, f x = f y",
        "type": "definition",
        "filename": "KL"
    },
    {
        "theorem_name": "exist_constant_value",
        "theorem_statement": " (f : E â†’ â„) (h : is_constant_on f Î©) (h_nonempty : Î©.Nonempty) : âˆƒ Î¼ : â„, âˆ€ x âˆˆ Î©, f x = Î¼",
        "variable": [],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem exist_constant_value (f : E â†’ â„) (h : is_constant_on f Î©) (h_nonempty : Î©.Nonempty) :\n    âˆƒ Î¼ : â„, âˆ€ x âˆˆ Î©, f x = Î¼ := by\n  rcases(Set.nonempty_def.1 h_nonempty) with âŸ¨x, hxâŸ©\n  exact âŸ¨f x, fun y hy => h y hy x hxâŸ©",
        "type": "theorem",
        "filename": "KL"
    },
    {
        "theorem_name": "uniformized_KL_property",
        "theorem_statement": " {f : E â†’ â„} {Î© : Set E} (h_compact : IsCompact Î©) (h_Î©1 : âˆ€ x âˆˆ Î©, KL_point f x) (h_Î©2 : is_constant_on f Î©) :\n  âˆƒ Îµ âˆˆ Ioi 0,\n    âˆƒ Î· âˆˆ Ioi 0,\n      âˆƒ Ï† âˆˆ desingularizing_function Î·,\n        âˆ€ u âˆˆ Î©,\n          âˆ€ x âˆˆ {y : E | (EMetric.infEdist y Î©).toReal < Îµ} âˆ© {y | f u < f y âˆ§ f y < f u + Î·},\n            (ENNReal.ofReal (deriv Ï† (f x - f u))) * EMetric.infEdist 0 (subdifferential f x) â‰¥ 1",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable\n  [InnerProductSpace â„ E]\n    /-  Uniformized KL property -/"
        ],
        "namespaces": [
            "Topology",
            "Set",
            "BigOperators",
            "Filter"
        ],
        "proof_process": "theorem uniformized_KL_property {f : E â†’ â„} {Î© : Set E} (h_compact : IsCompact Î©) (h_Î©1 : âˆ€ x âˆˆ Î©, KL_point f x)\n    (h_Î©2 : is_constant_on f Î©) :\n    âˆƒ Îµ âˆˆ Ioi 0,\n      âˆƒ Î· âˆˆ Ioi 0,\n        âˆƒ Ï† âˆˆ desingularizing_function Î·,\n          âˆ€ u âˆˆ Î©,\n            âˆ€ x âˆˆ {y : E | (EMetric.infEdist y Î©).toReal < Îµ} âˆ© {y | f u < f y âˆ§ f y < f u + Î·},\n              (ENNReal.ofReal (deriv Ï† (f x - f u))) * EMetric.infEdist 0 (subdifferential f x) â‰¥ 1 :=\n  by\n  -- case : Î© = âˆ…\n  by_cases h_nonempty : Î© = âˆ…\n  Â· push_neg at h_nonempty\n    use 1, (by simp), 1, (by simp), (fun t => 2â»Â¹ * t)\n    constructor\n    rw [â† div_self]\n    exact (const_mul_special_concave 2 (by simp))\n    simp\n    rw [h_nonempty]\n    tauto\n      -- case : Î© â‰  âˆ…\n  push_neg at h_nonempty\n  obtain âŸ¨Î¼, constant_valueâŸ© := exist_constant_value f h_Î©2 h_nonempty\n  have :\n    âˆ€ x âˆˆ Î©,\n      âˆƒ Î· âˆˆ Ioi 0,\n        âˆƒ (O : Set E) (_ : IsOpen O) (_ : x âˆˆ O),\n          âˆƒ Ï† âˆˆ desingularizing_function Î·,\n            âˆ€ u âˆˆ O âˆ© {y | f x < f y âˆ§ f y < f x + Î·},\n              (ENNReal.ofReal (deriv Ï† (f u - f x))) * EMetric.infEdist 0 (subdifferential f u) â‰¥ 1 :=\n    by\n    intro x hx; simp [KL_point] at h_Î©1\n    rcases h_Î©1 x hx with âŸ¨Î·, âŸ¨hÎ·, âŸ¨s, âŸ¨hs, âŸ¨Ï†, hÏ†, h_Î©1âŸ©âŸ©âŸ©âŸ©âŸ©\n    rcases mem_nhds_iff.1 hs with âŸ¨O, hO1, hO2, hO3âŸ©\n    use Î·, hÎ·, O, hO2, hO3, Ï†, hÏ†\n    intro u hu\n    simp at hu\n    rcases hu with âŸ¨hu1, hu2, hu3âŸ©\n    have : u âˆˆ s := by tauto\n    exact h_Î©1 u this hu2 hu3\n  choose! Î· h_exist using this\n  choose hÎ·2 h_exist using h_exist\n  choose! O h_exist using h_exist\n  choose h_Ox h_exist using h_exist\n  choose h_Ox' h_exist using h_exist\n  choose! Ï† h_exist using h_exist\n  choose hÏ† h_exist using h_exist\n  have exist_open_cover : Î© âŠ† â‹ƒ x âˆˆ Î©, O x := by\n    intro x hx; simp\n    exact\n      âŸ¨x, âŸ¨hx, h_Ox' x hxâŸ©âŸ©\n        -- There exists a finite sub-cover of this open cover.\n  obtain exist_open_sub_finite_cover := IsCompact.elim_finite_subcover_image h_compact h_Ox exist_open_cover\n  rcases exist_open_sub_finite_cover with âŸ¨t, ht1, ht2, ht3âŸ©\n  have mem_t_in_Î© : âˆ€ x âˆˆ ht2.toFinset, x âˆˆ Î© := by\n    intro x hx\n    obtain := (Set.Finite.mem_toFinset ht2).1 hx\n    tauto\n  have t_nonempty : ht2.toFinset.Nonempty := by\n    simp; by_contra! h\n    have : â‹ƒ i âˆˆ t, O i = âˆ… := by simp [h]\n    have Î©_subset : Î© âŠ† âˆ… := by rwa [this] at ht3\n    have contraâ‚ : Î© = âˆ… := Set.subset_empty_iff.1 Î©_subset\n    have contraâ‚‚ : Î© â‰  âˆ… := Set.Nonempty.ne_empty h_nonempty\n    contradiction\n  let Ï†_sum := âˆ‘' x : ht2.toFinset, Ï† x\n  have : âˆƒ Î·_min âˆˆ Ioi 0, âˆ€ x âˆˆ t, Î· x â‰¥ Î·_min :=\n    by\n    have nonempty : (Finset.image Î· ht2.toFinset).Nonempty := by simpa using t_nonempty\n    let Î·_min := (Finset.image Î· ht2.toFinset).min' nonempty\n    use Î·_min\n    constructor\n    Â· simp [Î·_min]\n      intro c hc\n      exact hÎ·2 c (mem_t_in_Î© c ((Set.Finite.mem_toFinset ht2).2 hc))\n    intro x xt\n    have min_le : âˆ€ s âˆˆ (Finset.image Î· ht2.toFinset), Î·_min â‰¤ s := by apply Finset.min'_le\n    have Î·_in_image : (Î· x) âˆˆ (Finset.image Î· ht2.toFinset) :=\n      by\n      rw [Finset.mem_image]\n      use x\n      constructor\n      simp [xt]\n      rfl\n    exact min_le (Î· x) Î·_in_image\n  rcases this with âŸ¨Î·_min, Î·pos, hminâŸ©\n  simp [desingularizing_function] at hÏ†\n  have h_special_concave : Ï†_sum âˆˆ desingularizing_function Î·_min :=\n    by\n    simp [desingularizing_function]\n    have hâ‚ : ConcaveOn â„ (Ico 0 Î·_min) Ï†_sum := by\n      rw [ConcaveOn]\n      constructor\n      apply convex_Ico\n      intro x xpos y ypos a b apos bpos absum\n      simp [Ï†_sum]\n      have : âˆ€ d : â„, âˆ€ x : â„, d * âˆ‘ c âˆˆ ht2.toFinset, Ï† c x = âˆ‘ c âˆˆ ht2.toFinset, d * (Ï† c x) :=\n        by\n        intro d x\n        let f c := Ï† c x\n        show d * âˆ‘ c âˆˆ ht2.toFinset, f c = âˆ‘ c âˆˆ ht2.toFinset, d * f c\n        rw [â† Finset.tsum_subtype', â† Finset.tsum_subtype', â† tsum_mul_left]\n      rw [this a x, this b y, â† Finset.sum_add_distrib]\n      have : âˆ€ c âˆˆ t, (a * Ï† c x + b * Ï† c y) â‰¤ Ï† c (a * x + b * y) :=\n        by\n        intro c hc\n        simp at xpos ypos\n        have xleq : x < Î· c := by\n          obtain := hmin c hc\n          linarith\n        have yleq : y < Î· c := by\n          obtain := hmin c hc\n          linarith\n        obtain c_in_finset := (Set.Finite.mem_toFinset ht2).2 hc\n        obtain inequ_concave := (hÏ† c (mem_t_in_Î© c c_in_finset)).1\n        simp [ConcaveOn] at inequ_concave\n        apply inequ_concave.2 xpos.1 xleq ypos.1 yleq apos bpos absum\n      apply Finset.sum_le_sum\n      intro c hc\n      exact\n        this c\n          ((Set.Finite.mem_toFinset ht2).1 hc)\n            -- have hâ‚‚ : âˆ€ (x : â„), 0 < x â†’ x < Î·_min â†’ 0 < Ï†_sum x := by\n                  --   intro x hx1 hx2; simp [Ï†_sum]\n                  --   apply Finset.sum_pos\n                  --   intro c hc\n                  --   have xleq : x < Î· c := by\n                  --     obtain := hmin c ((Set.Finite.mem_toFinset ht2).1 hc)\n                  --     linarith\n                  --   exact (hÏ† c (mem_t_in_Î© c hc)).2.1 x hx1 xleq\n                  --   exact t_nonempty\n    have hâ‚ƒ : Ï†_sum 0 = 0 := by\n      simp [Ï†_sum]\n      have : âˆ€ x âˆˆ ht2.toFinset, Ï† x 0 = 0 := by\n        intro x xt\n        exact (hÏ† x (mem_t_in_Î© x xt)).2.1\n      apply Finset.sum_eq_zero this\n    have hâ‚„ : ContDiffOn â„ 1 Ï†_sum (Ioo 0 Î·_min) :=\n      by\n      have : Ï†_sum = (fun c => âˆ‘ x âˆˆ ht2.toFinset, Ï† x c) := by ext c; simp [Ï†_sum]\n      rw [this]\n      apply ContDiffOn.sum\n      intro c hc\n      obtain Ï†_cont_diff := (hÏ† c (mem_t_in_Î© c hc)).2.2.1\n      apply ContDiffOn.mono Ï†_cont_diff\n      apply Set.Ioo_subset_Ioo_right\n      exact hmin c ((Set.Finite.mem_toFinset ht2).1 hc)\n    have hâ‚… : ContinuousAt Ï†_sum 0 := by\n      rw [ContinuousAt]\n      have : Ï†_sum = (fun c => âˆ‘ x âˆˆ ht2.toFinset, Ï† x c) := by ext c; simp [Ï†_sum]\n      rw [this]\n      simp [Ï†_sum]\n      apply tendsto_finset_sum\n      intro c hc\n      obtain cont := (hÏ† c (mem_t_in_Î© c hc)).2.2.2.1\n      rw [ContinuousAt] at cont\n      exact cont\n    have hâ‚† : âˆ€ (x : â„), 0 < x â†’ x < Î·_min â†’ 0 < deriv Ï†_sum x :=\n      by\n      intro y ypos yleq\n      have : Ï†_sum = (fun c => âˆ‘ x âˆˆ ht2.toFinset, Ï† x c) := by ext c; simp [Ï†_sum]\n      rw [this]\n      have : deriv (fun c â†¦ âˆ‘ x âˆˆ ht2.toFinset, Ï† x c) y = âˆ‘ x âˆˆ ht2.toFinset, deriv (Ï† x) y :=\n        by\n        apply deriv_sum\n        intro c hc\n        have Î·_inequ : y < Î· c := by\n          obtain := hmin c ((Set.Finite.mem_toFinset ht2).1 hc)\n          linarith\n        specialize hÏ† c (mem_t_in_Î© c hc)\n        obtain contdiff := ContDiffOn.contDiffAt hÏ†.2.2.1 (Ioo_mem_nhds ypos Î·_inequ)\n        apply ContDiffAt.differentiableAt contdiff (by simp)\n      rw [this]\n      apply Finset.sum_pos\n      Â· intro c hc\n        have : y < Î· c := by\n          obtain := hmin c ((Set.Finite.mem_toFinset ht2).1 hc)\n          linarith\n        specialize hÏ† c (mem_t_in_Î© c hc)\n        exact hÏ†.2.2.2.2 y ypos this\n      Â· exact t_nonempty\n    exact âŸ¨hâ‚, hâ‚ƒ, hâ‚„, hâ‚…, hâ‚†âŸ©\n  have uniform_ball : âˆƒ Îµ âˆˆ Ioi 0, {y | EMetric.infEdist y Î© < ENNReal.ofReal Îµ} âŠ† â‹ƒ x âˆˆ t, O x :=\n    by\n    have union_open : IsOpen (â‹ƒ x âˆˆ t, O x) :=\n      by\n      have : âˆ€ x âˆˆ t, IsOpen (O x) := by\n        intro x hx\n        have : x âˆˆ Î© := by tauto\n        apply h_Ox\n        apply this\n      apply isOpen_biUnion this\n    obtain res_thickening := IsCompact.exists_thickening_subset_open h_compact union_open ht3\n    rcases res_thickening with âŸ¨Îµ, âŸ¨hÎµ, h2âŸ©âŸ©\n    use Îµ, hÎµ\n    have : {y | EMetric.infEdist y Î© < ENNReal.ofReal Îµ} = Metric.thickening Îµ Î© := by ext x;\n      exact Metric.mem_thickening_iff_infEdist_lt\n    rwa [this]\n  choose Îµ uniform_ball using uniform_ball\n  have : {y | EMetric.infEdist y Î© < ENNReal.ofReal Îµ} = {y | (EMetric.infEdist y Î©).toReal < Îµ} := by ext x;\n    apply ENNReal.lt_ofReal_iff_toReal_lt (Metric.infEdist_ne_top h_nonempty)\n  rw [this] at uniform_ball\n  have exist_one_ball :\n    âˆ€ u âˆˆ {y | (EMetric.infEdist y Î©).toReal < Îµ} âˆ© {y | Î¼ < f y âˆ§ f y < Î¼ + Î·_min}, âˆƒ x âˆˆ t, u âˆˆ O x :=\n    by\n    intro u hu\n    obtain u_in_union := Set.mem_of_subset_of_mem uniform_ball.2 hu.1\n    simpa using u_in_union\n  use Îµ, uniform_ball.1, Î·_min, Î·pos, Ï†_sum, h_special_concave\n  intro baru hbaru\n  rw [constant_value baru hbaru]\n  intro u hu\n  rcases exist_one_ball u hu with âŸ¨ui, âŸ¨huiâ‚, huiâ‚‚âŸ©âŸ©\n  simp at hu\n  rcases hu with\n    âŸ¨_, hu2, hu3âŸ©\n      -- rcases hu with âŸ¨_, âŸ¨hu21 , âŸ¨hu221, hu222âŸ©âŸ©âŸ©\n  calc\n    _ â‰¥ (ENNReal.ofReal (deriv (Ï† ui) (f u - Î¼))) * EMetric.infEdist 0 (subdifferential f u) :=\n      by\n      have deriv_Ï†_pos : deriv Ï†_sum (f u - Î¼) > 0 :=\n        by\n        simp [desingularizing_function] at h_special_concave\n        obtain h_tmp := h_special_concave.2.2.2.2\n        apply h_tmp\n        Â· linarith [hu2]\n        Â· linarith [hu3]\n      apply real_geq_ennreal_ofreal_geq\n      simp [Ï†_sum]\n      have equâ‚ : deriv (fun c â†¦ âˆ‘ x âˆˆ ht2.toFinset, Ï† x c) (f u - Î¼) = âˆ‘ x âˆˆ ht2.toFinset, deriv (Ï† x) (f u - Î¼) :=\n        by\n        apply deriv_sum\n        intro c hc\n        have Ïƒu_pos : f u - Î¼ > 0 := by linarith [hu2]\n        have Î·_inequ : (f u - Î¼) < Î· c :=\n          by\n          obtain inequ_Î·min := hmin c ((Set.Finite.mem_toFinset ht2).1 hc)\n          linarith\n        specialize hÏ† c (mem_t_in_Î© c hc)\n        obtain contdiff := ContDiffOn.contDiffAt hÏ†.2.2.1 (Ioo_mem_nhds Ïƒu_pos Î·_inequ)\n        apply ContDiffAt.differentiableAt contdiff (by simp)\n      have equâ‚‚ : deriv (fun c â†¦ âˆ‘ x âˆˆ ht2.toFinset, Ï† x c) (f u - Î¼) = deriv (âˆ‘ x âˆˆ ht2.toFinset, Ï† x) (f u - Î¼) :=\n        by\n        have : (fun c â†¦ âˆ‘ x âˆˆ ht2.toFinset, Ï† x c) = (âˆ‘ x âˆˆ ht2.toFinset, Ï† x) := by ext c;\n          exact Eq.symm (Finset.sum_apply c ht2.toFinset Ï†)\n        rw [this]\n      rw [â† equâ‚‚, equâ‚]\n        -- have : (âˆ‘ x âˆˆ ht2.toFinset, deriv (Ï† x) (f u - Î¼)) â‰¥ deriv (Ï† ui) (f u - Î¼) := by\n      let g x := deriv (Ï† x) (f u - Î¼)\n      show (âˆ‘ x âˆˆ ht2.toFinset, g x) â‰¥ g ui\n      apply Finset.single_le_sum\n      intro c hc\n      have Ïƒu_pos : f u - Î¼ > 0 := by linarith [hu2]\n      have Î·_inequ : (f u - Î¼) < Î· c :=\n        by\n        obtain inequ_Î·min := hmin c ((Set.Finite.mem_toFinset ht2).1 hc)\n        linarith\n      simp [g]\n      specialize hÏ† c (mem_t_in_Î© c hc)\n      apply le_of_lt (hÏ†.2.2.2.2 (f u - Î¼) Ïƒu_pos Î·_inequ)\n      apply\n        ((Set.Finite.mem_toFinset ht2).2 huiâ‚)\n          -- apply real_geq_ennreal_ofreal_geq\n                  -- apply lt_of_lt_of_le _ this\n      exact deriv_Ï†_pos\n    _ â‰¥ 1 := by\n      obtain equ_Î¼ := constant_value ui (mem_t_in_Î© ui ((Set.Finite.mem_toFinset ht2).2 huiâ‚))\n      specialize h_exist ui (mem_t_in_Î© ui ((Set.Finite.mem_toFinset ht2).2 huiâ‚))\n      specialize h_exist u âŸ¨huiâ‚‚, _âŸ©\n      simp [equ_Î¼]\n      use hu2\n      have : Î·_min â‰¤ Î· ui := hmin ui huiâ‚\n      linarith\n      rw [equ_Î¼] at h_exist\n      exact h_exist",
        "type": "theorem",
        "filename": "KL"
    }
]