[
    {
        "theorem_name": "term_‚àá*",
        "theorem_statement": " : Lean.TrailingParserDescr‚úù",
        "variable": [],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "@[local term_parser 1000]\ndef term_‚àá*‚úù : Lean.TrailingParserDescr‚úù :=\n  ParserDescr.trailingNode‚úù\n    (Lean.Name.mkNum‚úù\n      (Lean.Name.mkStr‚úù (Lean.Name.mkStr‚úù (Lean.Name.mkStr‚úù Lean.Name.anonymous‚úù \"term_‚àá*\") \"_@\") \"_hyg\") 5)\n    1022 0 (ParserDescr.symbol‚úù \"‚àá*\")",
        "type": "definition",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "_aux___macroRules_term_‚àá*_1",
        "theorem_statement": " : Macro‚úù",
        "variable": [],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "",
        "type": "definition",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "term‚ü™_,_‚ü´",
        "theorem_statement": " : Lean.ParserDescr‚úù",
        "variable": [],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "@[local term_parser 1000]\ndef term‚ü™_,_‚ü´‚úù : Lean.ParserDescr‚úù :=\n  ParserDescr.node‚úù\n    (Lean.Name.mkNum‚úù\n      (Lean.Name.mkStr‚úù (Lean.Name.mkStr‚úù (Lean.Name.mkStr‚úù Lean.Name.anonymous‚úù \"term‚ü™_,_‚ü´\") \"_@\") \"_hyg\") 190)\n    1024\n    (ParserDescr.binary‚úù `andthen\n      (ParserDescr.binary‚úù `andthen\n        (ParserDescr.binary‚úù `andthen\n          (ParserDescr.binary‚úù `andthen (ParserDescr.symbol‚úù \"‚ü™\") (ParserDescr.cat‚úù `term 0))\n          (ParserDescr.symbol‚úù \", \"))\n        (ParserDescr.cat‚úù `term 0))\n      (ParserDescr.symbol‚úù \"‚ü´\"))",
        "type": "definition",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "_aux___macroRules_term‚ü™_,_‚ü´_1",
        "theorem_statement": " : Macro‚úù",
        "variable": [],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "@[macro term‚ü™_,_‚ü´‚úù]\ndef ¬´_aux___macroRules_term‚ü™_,_‚ü´_1¬ª : Macro‚úù := fun\n  | `(‚ü™$x, $y‚ü´) => ``(@inner ‚Ñù _ _ $x $y)\n  | _ => no_error_if_unused% throw‚úù Lean.Macro.Exception.unsupportedSyntax‚úù",
        "type": "definition",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientAt",
        "theorem_statement": " (f : E ‚Üí ‚Ñù) (g x : E) : Prop",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- Subgradient of functions --/\ndef HasSubgradientAt (f : E ‚Üí ‚Ñù) (g x : E) : Prop :=\n  ‚àÄ y, f y ‚â• f x + ‚ü™g, y - x‚ü´",
        "type": "definition",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientWithinAt",
        "theorem_statement": " (f : E ‚Üí ‚Ñù) (g : E) (s : Set E) (x : E) : Prop",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "def HasSubgradientWithinAt (f : E ‚Üí ‚Ñù) (g : E) (s : Set E) (x : E) : Prop :=\n  ‚àÄ y ‚àà s, f y ‚â• f x + ‚ü™g, y - x‚ü´",
        "type": "definition",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " (f : E ‚Üí ‚Ñù) (x : E) : Set E",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- Subderiv of functions --/\ndef SubderivAt (f : E ‚Üí ‚Ñù) (x : E) : Set E :=\n  {g : E | HasSubgradientAt f g x}",
        "type": "definition",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivWithinAt",
        "theorem_statement": " (f : E ‚Üí ‚Ñù) (s : Set E) (x : E) : Set E",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "def SubderivWithinAt (f : E ‚Üí ‚Ñù) (s : Set E) (x : E) : Set E :=\n  {g : E | HasSubgradientWithinAt f g s x}",
        "type": "definition",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "mem_SubderivAt",
        "theorem_statement": " : HasSubgradientAt f g x ‚Üî g ‚àà SubderivAt f x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "@[simp]\ntheorem mem_SubderivAt : HasSubgradientAt f g x ‚Üî g ‚àà SubderivAt f x :=\n  ‚ü®id, id‚ü©",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "hasSubgradientWithinAt_univ",
        "theorem_statement": " : HasSubgradientWithinAt f g univ x ‚Üî HasSubgradientAt f g x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "@[simp]\ntheorem hasSubgradientWithinAt_univ : HasSubgradientWithinAt f g univ x ‚Üî HasSubgradientAt f g x :=\n  ‚ü®fun h y => h y trivial, fun h y _ => h y‚ü©",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientAt",
        "theorem_statement": " : HasSubgradientAt f g x ‚Üí HasSubgradientWithinAt f g s x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem hasSubgradientWithinAt : HasSubgradientAt f g x ‚Üí HasSubgradientWithinAt f g s x := fun h y _ => h y",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt_SubderivWithinAt",
        "theorem_statement": " : SubderivAt f x = SubderivWithinAt f univ x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem SubderivAt_SubderivWithinAt : SubderivAt f x = SubderivWithinAt f univ x := by\n  simp only [SubderivAt, SubderivWithinAt, hasSubgradientWithinAt_univ]",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientAt_HasBanachSubgradientAt",
        "theorem_statement": " {f : E ‚Üí ‚Ñù} {g : E} {x : E} : HasSubgradientAt f g x ‚Üî Banach_HasSubgradientAt f (toDual ‚Ñù E g) x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem HasSubgradientAt_HasBanachSubgradientAt {f : E ‚Üí ‚Ñù} {g : E} {x : E} :\n    HasSubgradientAt f g x ‚Üî Banach_HasSubgradientAt f (toDual ‚Ñù E g) x :=\n  by\n  constructor\n  ¬∑ intro h z\n    unfold HasSubgradientAt at h\n    obtain hz := h z\n    simp; linarith\n  intro h z\n  unfold Banach_HasSubgradientAt at h\n  obtain hz := h z; simp at hz\n  linarith",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasBanachSubgradientAt_HasSubgradientAt",
        "theorem_statement": " {f : E ‚Üí ‚Ñù} {g : E ‚ÜíL[‚Ñù] ‚Ñù} {x : E} : Banach_HasSubgradientAt f g x ‚Üî HasSubgradientAt f ((toDual ‚Ñù E).symm g) x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem HasBanachSubgradientAt_HasSubgradientAt {f : E ‚Üí ‚Ñù} {g : E ‚ÜíL[‚Ñù] ‚Ñù} {x : E} :\n    Banach_HasSubgradientAt f g x ‚Üî HasSubgradientAt f ((toDual ‚Ñù E).symm g) x :=\n  by\n  constructor\n  ¬∑ intro h z\n    unfold Banach_HasSubgradientAt at h\n    obtain hz := h z\n    simp; rw [‚Üê ContinuousLinearMap.map_sub]; linarith\n  intro h z\n  unfold HasSubgradientAt at h\n  obtain hz := h z; simp at hz\n  rw [ContinuousLinearMap.map_sub]; linarith",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientWithinAt_HasBanachSubgradientWithinAt",
        "theorem_statement": " {f : E ‚Üí ‚Ñù} {g : E} {x : E} : HasSubgradientWithinAt f g s x ‚Üî Banach_HasSubgradientWithinAt f (toDual ‚Ñù E g) s x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem HasSubgradientWithinAt_HasBanachSubgradientWithinAt {f : E ‚Üí ‚Ñù} {g : E} {x : E} :\n    HasSubgradientWithinAt f g s x ‚Üî Banach_HasSubgradientWithinAt f (toDual ‚Ñù E g) s x :=\n  by\n  constructor\n  ¬∑ intro h z hz\n    unfold HasSubgradientAt at h\n    obtain hz := h z hz\n    simp; linarith\n  intro h z hz\n  unfold Banach_HasSubgradientAt at h\n  obtain hz := h z hz; simp at hz\n  linarith",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasBanachSubgradientWithinAt_HasSubgradientWithinAt",
        "theorem_statement": " {f : E ‚Üí ‚Ñù} {g : E ‚ÜíL[‚Ñù] ‚Ñù} {x : E} :\n  Banach_HasSubgradientWithinAt f g s x ‚Üî HasSubgradientWithinAt f ((toDual ‚Ñù E).symm g) s x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem HasBanachSubgradientWithinAt_HasSubgradientWithinAt {f : E ‚Üí ‚Ñù} {g : E ‚ÜíL[‚Ñù] ‚Ñù} {x : E} :\n    Banach_HasSubgradientWithinAt f g s x ‚Üî HasSubgradientWithinAt f ((toDual ‚Ñù E).symm g) s x :=\n  by\n  constructor\n  ¬∑ intro h z hz\n    unfold Banach_HasSubgradientAt at h\n    obtain hz := h z hz\n    simp; rw [‚Üê ContinuousLinearMap.map_sub]; linarith\n  intro h z hz\n  unfold HasSubgradientAt at h\n  obtain hz := h z hz; simp at hz\n  rw [ContinuousLinearMap.map_sub]; linarith",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " (h : f‚ÇÅ = f‚ÇÇ) : SubderivAt f‚ÇÅ x = SubderivAt f‚ÇÇ x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem congr (h : f‚ÇÅ = f‚ÇÇ) : SubderivAt f‚ÇÅ x = SubderivAt f‚ÇÇ x := by ext g; rw [h]",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivWithinAt",
        "theorem_statement": " (h : ‚àÄ y ‚àà s, f‚ÇÅ y = f‚ÇÇ y) (hf : f‚ÇÅ x = f‚ÇÇ x) : SubderivWithinAt f‚ÇÅ s x = SubderivWithinAt f‚ÇÇ s x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem congr (h : ‚àÄ y ‚àà s, f‚ÇÅ y = f‚ÇÇ y) (hf : f‚ÇÅ x = f‚ÇÇ x) : SubderivWithinAt f‚ÇÅ s x = SubderivWithinAt f‚ÇÇ s x :=\n  by\n  ext g\n  exact ‚ü®fun hg y ys => by rw [‚Üê h y ys, ‚Üê hf]; exact hg y ys, fun hg y ys => by rw [h y ys, hf]; exact hg y ys‚ü©",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivWithinAt",
        "theorem_statement": " (xs : x ‚àà s) (h : ‚àÄ y ‚àà s, f‚ÇÅ y = f‚ÇÇ y) : SubderivWithinAt f‚ÇÅ s x = SubderivWithinAt f‚ÇÇ s x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem congr_of_mem (xs : x ‚àà s) (h : ‚àÄ y ‚àà s, f‚ÇÅ y = f‚ÇÇ y) : SubderivWithinAt f‚ÇÅ s x = SubderivWithinAt f‚ÇÇ s x :=\n  congr h (h x xs)",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " (h : ‚àÄ y ‚àà s, f‚ÇÅ y = f‚ÇÇ y) (hx : f‚ÇÅ x = f‚ÇÇ x) (h‚ÇÅ : t ‚äÜ s) : SubderivWithinAt f‚ÇÅ t x = SubderivWithinAt f‚ÇÇ t x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem congr_mono (h : ‚àÄ y ‚àà s, f‚ÇÅ y = f‚ÇÇ y) (hx : f‚ÇÅ x = f‚ÇÇ x) (h‚ÇÅ : t ‚äÜ s) :\n    SubderivWithinAt f‚ÇÅ t x = SubderivWithinAt f‚ÇÇ t x :=\n  SubderivWithinAt.congr (fun y a => h y (h‚ÇÅ a)) hx",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " : ‚àÄ x, IsClosed (SubderivAt f x)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- The subderiv of `f` at `x` is a closed set. --/\ntheorem isClosed : ‚àÄ x, IsClosed (SubderivAt f x) := by\n  intro x\n  by_cases e : SubderivAt f x = ‚àÖ\n  ¬∑ apply Eq.subst (Eq.symm e) isClosed_empty\n  rw [‚Üê isSeqClosed_iff_isClosed]\n  intro g g' hg cg y\n  obtain cg' := Tendsto.const_add (f x) (Filter.Tendsto.inner cg tendsto_const_nhds)\n  apply le_of_tendsto_of_tendsto' cg' tendsto_const_nhds (fun n => hg n y)",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivWithinAt",
        "theorem_statement": " : ‚àÄ x, IsClosed (SubderivWithinAt f s x)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem isClosed : ‚àÄ x, IsClosed (SubderivWithinAt f s x) :=\n  by\n  intro x\n  by_cases e : SubderivWithinAt f s x = ‚àÖ\n  ¬∑ apply Eq.subst (Eq.symm e) isClosed_empty\n  rw [‚Üê isSeqClosed_iff_isClosed]\n  intro g g' hg cg y ys\n  obtain cg' := Tendsto.const_add (f x) (Filter.Tendsto.inner cg tendsto_const_nhds)\n  apply le_of_tendsto_of_tendsto' cg' tendsto_const_nhds (fun n => hg n y ys)",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " : ‚àÄ x, Convex ‚Ñù (SubderivAt f x)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- The subderiv of `f` at `x` is a convex set. --/\ntheorem convex : ‚àÄ x, Convex ‚Ñù (SubderivAt f x) := by\n  intro x\n  by_cases e : SubderivAt f x = ‚àÖ\n  ¬∑ apply Eq.subst (Eq.symm e) convex_empty\n  intro g‚ÇÅ h1 g‚ÇÇ h2 a b lea leb abeq y\n  have ineq1 : a ‚Ä¢ f y ‚â• a ‚Ä¢ f x + a ‚Ä¢ ‚ü™g‚ÇÅ, y - x‚ü´ :=\n    by\n    rw [‚Üê smul_add]\n    apply smul_le_smul_of_nonneg_left (h1 y) lea\n  have ineq2 : b ‚Ä¢ f y ‚â• b ‚Ä¢ f x + b ‚Ä¢ inner g‚ÇÇ (y - x) :=\n    by\n    rw [‚Üê smul_add]\n    apply smul_le_smul_of_nonneg_left (h2 y) leb\n  have eq :\n    (a ‚Ä¢ f x + a ‚Ä¢ inner g‚ÇÅ (y - x)) + (b ‚Ä¢ f x + b ‚Ä¢ inner g‚ÇÇ (y - x)) = f x + inner (a ‚Ä¢ g‚ÇÅ + b ‚Ä¢ g‚ÇÇ) (y - x) :=\n    by\n    rw [add_add_add_comm, ‚Üê Eq.symm (Convex.combo_self abeq (f x))]\n    apply congrArg (HAdd.hAdd (f x))\n    rw [inner_add_left, inner_smul_left, inner_smul_left]; rfl\n  rw [Eq.symm (Convex.combo_self abeq (f y)), ‚Üê eq]\n  apply add_le_add ineq1 ineq2",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivWithinAt",
        "theorem_statement": " : ‚àÄ x ‚àà s, Convex ‚Ñù (SubderivWithinAt f s x)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem convex : ‚àÄ x ‚àà s, Convex ‚Ñù (SubderivWithinAt f s x) :=\n  by\n  intro x _\n  by_cases e : SubderivWithinAt f s x = ‚àÖ\n  ¬∑ apply Eq.subst (Eq.symm e) convex_empty\n  intro g‚ÇÅ h1 g‚ÇÇ h2 a b lea leb abeq y ys\n  have ineq1 : a ‚Ä¢ f y ‚â• a ‚Ä¢ f x + a ‚Ä¢ ‚ü™g‚ÇÅ, y - x‚ü´ :=\n    by\n    rw [‚Üê smul_add]\n    apply smul_le_smul_of_nonneg_left (h1 y ys) lea\n  have ineq2 : b ‚Ä¢ f y ‚â• b ‚Ä¢ f x + b ‚Ä¢ inner g‚ÇÇ (y - x) :=\n    by\n    rw [‚Üê smul_add]\n    apply smul_le_smul_of_nonneg_left (h2 y ys) leb\n  have eq :\n    (a ‚Ä¢ f x + a ‚Ä¢ inner g‚ÇÅ (y - x)) + (b ‚Ä¢ f x + b ‚Ä¢ inner g‚ÇÇ (y - x)) = f x + inner (a ‚Ä¢ g‚ÇÅ + b ‚Ä¢ g‚ÇÇ) (y - x) :=\n    by\n    rw [add_add_add_comm, ‚Üê Eq.symm (Convex.combo_self abeq (f x))]\n    apply congrArg (HAdd.hAdd (f x))\n    rw [inner_add_left, inner_smul_left, inner_smul_left]; rfl\n  rw [Eq.symm (Convex.combo_self abeq (f y)), ‚Üê eq]\n  apply add_le_add ineq1 ineq2",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "subgradientAt_mono",
        "theorem_statement": " {u v : E} {f : E ‚Üí ‚Ñù} {y : E} (hu : u ‚àà SubderivAt f x) (hv : v ‚àà SubderivAt f y) : ‚ü™u - v, x - y‚ü´ ‚â• (0 : ‚Ñù)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù}",
            "variable {t s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- Monotonicity of subderiv--/\ntheorem subgradientAt_mono {u v : E} {f : E ‚Üí ‚Ñù} {y : E} (hu : u ‚àà SubderivAt f x) (hv : v ‚àà SubderivAt f y) :\n    ‚ü™u - v, x - y‚ü´ ‚â• (0 : ‚Ñù) := by\n  specialize hu y; specialize hv x\n  have ineq1 : ‚ü™u, x - y‚ü´ ‚â• f x - f y := by rw [congrArg (inner u) (Eq.symm (neg_sub y x)), inner_neg_right]; linarith\n  have _ : inner v (x - y) ‚â§ f x - f y := Iff.mpr le_sub_iff_add_le' hv\n  rw [inner_sub_left]; linarith",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivWithinAt",
        "theorem_statement": " (hf : ConvexOn ‚Ñù s f) (hc : ContinuousOn f (interior s)) : ‚àÄ x ‚àà interior s, (SubderivWithinAt f s x).Nonempty",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x y : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Bornology",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem Nonempty (hf : ConvexOn ‚Ñù s f) (hc : ContinuousOn f (interior s)) :\n    ‚àÄ x ‚àà interior s, (SubderivWithinAt f s x).Nonempty :=\n  by\n  intro x hx\n  obtain h := Banach_SubderivWithinAt.Nonempty hf hc hx\n  unfold Set.Nonempty at h ‚ä¢\n  rcases h with ‚ü®g, hg‚ü©; unfold Banach_SubderivWithinAt at hg\n  simp at hg\n  rw [HasBanachSubgradientWithinAt_HasSubgradientWithinAt] at hg; use (toDual ‚Ñù E).symm g; unfold SubderivWithinAt\n  simp [hg]",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " (hf : ConvexOn ‚Ñù univ f) (hc : ContinuousOn f univ) : ‚àÄ x, Nonempty (SubderivAt f x)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x y : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Bornology",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem nonempty (hf : ConvexOn ‚Ñù univ f) (hc : ContinuousOn f univ) : ‚àÄ x, Nonempty (SubderivAt f x) :=\n  by\n  intro x\n  rw [SubderivAt_SubderivWithinAt]\n  have : x ‚àà interior univ := by simp\n  rw [‚Üê interior_univ] at hc\n  obtain h := SubderivWithinAt.Nonempty hf hc x this\n  simp [h]\n  rcases h with ‚ü®a, ha‚ü©\n  exact ‚ü®a, ha‚ü©",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivWithinAt_eq_gradient",
        "theorem_statement": " {f'x : E} (hx : x ‚àà interior s) (hf : ConvexOn ‚Ñù s f) (h : HasGradientAt f (f'x) x) : SubderivWithinAt f s x = { f'x }",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x y : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Pointwise",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- Subderiv of differentiable convex functions --/\ntheorem SubderivWithinAt_eq_gradient {f'x : E} (hx : x ‚àà interior s) (hf : ConvexOn ‚Ñù s f)\n    (h : HasGradientAt f (f'x) x) : SubderivWithinAt f s x = { f'x } :=\n  by\n  obtain h' := hasGradientAt_iff_hasFDerivAt.mp h\n  let g := f'x\n  rw [Set.eq_singleton_iff_nonempty_unique_mem]\n  constructor\n  ¬∑ use g; intro y ys\n    apply Convex_first_order_condition' h hf (interior_subset hx) y ys\n  intro g' hg'; by_contra neq\n  apply not_le_of_lt (norm_sub_pos_iff.mpr neq)\n  let v := g' - g; obtain vneq := sub_ne_zero.mpr neq\n  have : Tendsto (fun (t : ‚Ñù) => (f (x + t ‚Ä¢ v) - f x - ‚ü™g, t ‚Ä¢ v‚ü´) * ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π) (ùìù[>] 0) (ùìù 0) :=\n    by\n    rw [Metric.tendsto_nhdsWithin_nhds]; intro Œµ Œµpos\n    unfold HasFDerivAt at h'\n    rw [hasFDerivAtFilter_iff_tendsto, Metric.tendsto_nhds_nhds] at h'\n    obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© := h' Œµ Œµpos\n    use (Œ¥ * ‚Äñv‚Äñ‚Åª¬π)\n    obtain pos := mul_pos Œ¥pos (inv_pos.mpr (norm_pos_iff.mpr vneq))\n    constructor\n    ¬∑ exact pos\n    intro t _ ht; rw [dist_eq_norm] at ht; rw [dist_eq_norm]\n    have : dist (x + t ‚Ä¢ v) x < Œ¥ :=\n      by\n      rw [dist_eq_norm, add_sub_cancel_left, norm_smul, ‚Üê (sub_zero t)]\n      apply lt_of_lt_of_eq ((mul_lt_mul_right (norm_sub_pos_iff.mpr neq)).mpr ht)\n      rw [mul_assoc, inv_mul_cancel‚ÇÄ (norm_ne_zero_iff.mpr vneq), mul_one]\n    specialize hŒ¥ this; rw [dist_eq_norm] at hŒ¥\n    have eq1 : ‚Äñ‚Äñx + t ‚Ä¢ v - x‚Äñ‚Åª¬π‚Äñ = ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π := by rw [add_sub_cancel_left, norm_inv, norm_norm]\n    have eq2 : (g‚àá*) (x + t ‚Ä¢ v - x) = ‚ü™g, t ‚Ä¢ v‚ü´ := by rw [add_sub_cancel_left]; exact rfl\n    have eq3 : ‚Äñ(f (x + t ‚Ä¢ v) - f x - ‚ü™g, t ‚Ä¢ v‚ü´) * ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π - 0‚Äñ = ‚Äñf (x + t ‚Ä¢ v) - f x - ‚ü™g, t ‚Ä¢ v‚ü´‚Äñ * ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π :=\n      by rw [sub_zero, norm_mul, norm_inv, norm_norm]\n    have eq :\n      ‚Äñ‚Äñx + t ‚Ä¢ v - x‚Äñ‚Åª¬π * ‚Äñf (x + t ‚Ä¢ v) - f x - (g‚àá*) (x + t ‚Ä¢ v - x)‚Äñ - 0‚Äñ =\n        ‚Äñ(f (x + t ‚Ä¢ v) - f x - ‚ü™g, t ‚Ä¢ v‚ü´) * ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π - 0‚Äñ :=\n      by rw [sub_zero, norm_mul, norm_norm, mul_comm, eq1, eq2, ‚Üê eq3]\n    apply Eq.trans_lt (Eq.symm eq) hŒ¥\n  apply ge_of_tendsto this\n  rw [Filter.Eventually, Metric.mem_nhdsWithin_iff]\n  rw [mem_interior_iff_mem_nhds, Metric.mem_nhds_iff] at hx\n  obtain ‚ü®Œµ, Œµpos, ballmem‚ü© := hx\n  obtain pos := mul_pos Œµpos (inv_pos.mpr (norm_pos_iff.mpr vneq))\n  use (Œµ * ‚Äñv‚Äñ‚Åª¬π); use pos; intro t ht\n  have tball := ht.1; have tlt : t > 0 := ht.2\n  have tvpos : ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π > 0 := by\n    apply inv_pos.mpr; rw [norm_smul]\n    apply smul_pos (abs_pos_of_pos tlt) (norm_sub_pos_iff.mpr neq)\n  have mems : x + t ‚Ä¢ v ‚àà s := by\n    apply ballmem\n    rw [mem_ball_iff_norm, sub_zero] at tball\n    rw [mem_ball_iff_norm, add_sub_cancel_left, norm_smul]\n    have : ‚Äñt‚Äñ * ‚Äñv‚Äñ < Œµ * ‚Äñv‚Äñ‚Åª¬π * ‚Äñv‚Äñ := by apply (mul_lt_mul_right (norm_sub_pos_iff.mpr neq)).mpr tball\n    rwa [mul_assoc, inv_mul_cancel‚ÇÄ (norm_ne_zero_iff.mpr vneq), mul_one] at this\n  obtain ineq1 := hg' (x + t ‚Ä¢ v); rw [add_sub_cancel_left] at ineq1\n  have eq1 : ‚Äñv‚Äñ = (‚ü™g', t ‚Ä¢ v‚ü´ - ‚ü™g, t ‚Ä¢ v‚ü´) * ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π :=\n    by\n    have eq2 : ‚Äñv‚Äñ = ‚ü™v, v‚ü´ * ‚Äñv‚Äñ‚Åª¬π := by\n      rw [real_inner_self_eq_norm_sq]\n      apply (div_eq_iff _).mp\n      ¬∑ rw [div_inv_eq_mul, pow_two]\n      exact inv_ne_zero (norm_ne_zero_iff.mpr vneq)\n    have eq3 : ‚ü™v, v‚ü´ * ‚Äñv‚Äñ‚Åª¬π = ‚ü™v, t ‚Ä¢ v‚ü´ * ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π :=\n      by\n      have : ‚ü™v, t ‚Ä¢ v‚ü´ = ‚ü™v, v‚ü´ * t := by rw [inner_smul_right, mul_comm]\n      rw [this, mul_assoc]\n      have : ‚Äñv‚Äñ‚Åª¬π = t * ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π := by\n        have : t * ‚Äñt ‚Ä¢ v‚Äñ‚Åª¬π = t / ‚Äñt ‚Ä¢ v‚Äñ := rfl\n        rw [this, inv_eq_one_div]\n        have : t = ‚Äñt‚Äñ := by\n          have : ‚Äñt‚Äñ = |t| := rfl\n          rw [this, abs_of_pos tlt]\n        rw [this, norm_smul, norm_norm, div_mul_eq_div_div, div_self]\n        rw [norm_ne_zero_iff]\n        exact ne_of_gt tlt\n      rw [this]\n    rw [eq2, eq3, mul_eq_mul_right_iff]; left; rw [inner_sub_left]\n  rw [mem_setOf, eq1, mul_le_mul_right tvpos]\n  apply sub_le_sub_right (le_sub_iff_add_le'.mpr (ineq1 mems))",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivWithinAt_eq_FDeriv",
        "theorem_statement": " {f' : E ‚Üí (E ‚ÜíL[‚Ñù] ‚Ñù)} (hx : x ‚àà interior s) (hf : ConvexOn ‚Ñù s f) (h : HasFDerivAt f (f' x) x) :\n  SubderivWithinAt f s x = {(toDual ‚Ñù E).symm (f' x)}",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x y : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Pointwise",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- Alternarive version for FDeriv --/\ntheorem SubderivWithinAt_eq_FDeriv {f' : E ‚Üí (E ‚ÜíL[‚Ñù] ‚Ñù)} (hx : x ‚àà interior s) (hf : ConvexOn ‚Ñù s f)\n    (h : HasFDerivAt f (f' x) x) : SubderivWithinAt f s x = {(toDual ‚Ñù E).symm (f' x)} :=\n  by\n  have h‚ÇÅ : HasFDerivAt f ((toDual ‚Ñù E) ((LinearIsometryEquiv.symm (toDual ‚Ñù E)) (f' x))) x := by simp [h]\n  obtain h' := hasGradientAt_iff_hasFDerivAt.mpr h‚ÇÅ\n  apply SubderivWithinAt_eq_gradient hx hf\n  exact h'",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt_eq_gradient",
        "theorem_statement": " {f'x : E} (hf : ConvexOn ‚Ñù univ f) (h : HasGradientAt f (f'x) x) : SubderivAt f x = { f'x }",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable [CompleteSpace E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x y : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Pointwise",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem SubderivAt_eq_gradient {f'x : E} (hf : ConvexOn ‚Ñù univ f) (h : HasGradientAt f (f'x) x) :\n    SubderivAt f x = { f'x } := by\n  rw [SubderivAt_SubderivWithinAt]\n  apply SubderivWithinAt_eq_gradient _ hf h\n  ¬∑ simp only [interior_univ, mem_univ]",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientAt_zero_of_isMinOn",
        "theorem_statement": " (h : IsMinOn f univ x) : HasSubgradientAt f 0 x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem HasSubgradientAt_zero_of_isMinOn (h : IsMinOn f univ x) : HasSubgradientAt f 0 x := fun y =>\n  le_of_le_of_eq' (h trivial) (by rw [inner_zero_left, add_zero])",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "isMinOn_of_HasSubgradentAt_zero",
        "theorem_statement": " (h : HasSubgradientAt f 0 x) : IsMinOn f univ x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem isMinOn_of_HasSubgradentAt_zero (h : HasSubgradientAt f 0 x) : IsMinOn f univ x :=\n  by\n  intro y _; specialize h y\n  rwa [inner_zero_left, add_zero] at h",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientAt_zero_iff_isMinOn",
        "theorem_statement": " : HasSubgradientAt f 0 x ‚Üî IsMinOn f univ x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- `x'` minimize `f` if and only if `0` is a subgradient of `f` at `x'` --/\ntheorem HasSubgradientAt_zero_iff_isMinOn : HasSubgradientAt f 0 x ‚Üî IsMinOn f univ x :=\n  ‚ü®isMinOn_of_HasSubgradentAt_zero, HasSubgradientAt_zero_of_isMinOn‚ü©",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientWithinAt_zero_of_isMinOn",
        "theorem_statement": " (h : IsMinOn f s x) : HasSubgradientWithinAt f 0 s x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem HasSubgradientWithinAt_zero_of_isMinOn (h : IsMinOn f s x) : HasSubgradientWithinAt f 0 s x := fun y ys =>\n  le_of_le_of_eq' (h ys) (by rw [inner_zero_left, add_zero])",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "isMinOn_of_HasSubgradentWithinAt_zero",
        "theorem_statement": " (h : HasSubgradientWithinAt f 0 s x) : IsMinOn f s x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem isMinOn_of_HasSubgradentWithinAt_zero (h : HasSubgradientWithinAt f 0 s x) : IsMinOn f s x :=\n  by\n  intro y ys; specialize h y ys\n  rwa [inner_zero_left, add_zero] at h",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientWithinAt_zero_iff_isMinOn",
        "theorem_statement": " : HasSubgradientWithinAt f 0 s x ‚Üî IsMinOn f s x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem HasSubgradientWithinAt_zero_iff_isMinOn : HasSubgradientWithinAt f 0 s x ‚Üî IsMinOn f s x :=\n  ‚ü®isMinOn_of_HasSubgradentWithinAt_zero, HasSubgradientWithinAt_zero_of_isMinOn‚ü©",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt_zero",
        "theorem_statement": " (xm : E) : 0 ‚àà SubderivAt f xm ‚Üî ‚àÄ y, f y ‚â• f xm + ‚ü™0, y - xm‚ü´",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem SubderivAt_zero (xm : E) : 0 ‚àà SubderivAt f xm ‚Üî ‚àÄ y, f y ‚â• f xm + ‚ü™0, y - xm‚ü´ := by rfl",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "first_order_convex_iff_subgradient",
        "theorem_statement": " (f : E ‚Üí ‚Ñù) (xm : E) : IsMinOn f univ xm ‚Üî 0 ‚àà SubderivAt f xm",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem first_order_convex_iff_subgradient (f : E ‚Üí ‚Ñù) (xm : E) : IsMinOn f univ xm ‚Üî 0 ‚àà SubderivAt f xm :=\n  by\n  rw [SubderivAt_zero xm, isMinOn_iff]\n  constructor\n  ¬∑ intro h y\n    simp only [inner_zero_left, add_zero, ge_iff_le]\n    apply h y\n    simp only [mem_univ]\n  ¬∑ intro h x _\n    have := h x\n    simp only [inner_zero_left, add_zero, ge_iff_le] at this\n    exact this",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "HasSubgradientAt",
        "theorem_statement": " {c : ‚Ñù} (h : HasSubgradientAt f g x) (hc : 0 < c) : HasSubgradientAt (c ‚Ä¢ f) (c ‚Ä¢ g) x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Pointwise",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- Multiplication by a Positive Scalar--/\ntheorem pos_smul {c : ‚Ñù} (h : HasSubgradientAt f g x) (hc : 0 < c) : HasSubgradientAt (c ‚Ä¢ f) (c ‚Ä¢ g) x :=\n  by\n  intro y; rw [inner_smul_left]\n  have ineq : c * f y ‚â• c * (f x + inner g (y - x)) := (mul_le_mul_left hc).mpr (h y)\n  have eq : c * (f x + inner g (y - x)) = c * f x + c * inner g (y - x) := mul_add c (f x) (inner g (y - x))\n  exact Eq.trans_le (id eq.symm) ineq",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " {c : ‚Ñù} (hc : 0 < c) : SubderivAt (c ‚Ä¢ f) x = c ‚Ä¢ (SubderivAt f x)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Pointwise",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem pos_smul {c : ‚Ñù} (hc : 0 < c) : SubderivAt (c ‚Ä¢ f) x = c ‚Ä¢ (SubderivAt f x) :=\n  by\n  ext g\n  constructor\n  ¬∑ intro hg; use (c‚Åª¬π ‚Ä¢ g)\n    constructor\n    ¬∑ intro y; have neq : c ‚â† 0 := ne_of_gt hc\n      calc\n        f y = c‚Åª¬π * (c * f y) := (eq_inv_mul_iff_mul_eq‚ÇÄ neq).mpr rfl\n        _ ‚â• c‚Åª¬π * (c * f x + inner g (y - x)) := (mul_le_mul_of_nonneg_left (hg y) (inv_nonneg.mpr (le_of_lt hc)))\n        _ = f x + inner (c‚Åª¬π ‚Ä¢ g) (y - x) :=\n          by\n          rw [mul_add, inner_smul_left, ‚Üê ((eq_inv_mul_iff_mul_eq‚ÇÄ neq).mpr rfl)]\n          rfl\n    exact smul_inv_smul‚ÇÄ (ne_of_gt hc) g\n  rintro ‚ü®gg, hgg, eq‚ü©; intro y\n  calc\n    c * f y ‚â• c * (f x + inner gg (y - x)) := (mul_le_mul_left hc).mpr (hgg y)\n    _ = c * f x + c * inner gg (y - x) := (mul_add c (f x) (inner gg (y - x)))\n    _ = c * f x + inner (c ‚Ä¢ gg) (y - x) := by rw [inner_smul_left]; exact rfl\n    _ = c * f x + inner g (y - x) := by rw [‚Üê eq]",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù} : ‚àÄ (x : E), SubderivAt f‚ÇÅ x + SubderivAt f‚ÇÇ x ‚äÜ SubderivAt (f‚ÇÅ + f‚ÇÇ) x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Pointwise",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "/-- Subderivatives of the sum of two functions is a subset of the sum of the\nsubderivatives of the two functions --/\ntheorem add_subset {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù} : ‚àÄ (x : E), SubderivAt f‚ÇÅ x + SubderivAt f‚ÇÇ x ‚äÜ SubderivAt (f‚ÇÅ + f‚ÇÇ) x :=\n  by\n  intro x y hy y'\n  obtain ‚ü®y‚ÇÅ, hy‚ÇÅ, y‚ÇÇ, hy‚ÇÇ, eq‚ü© := Set.mem_add.mpr hy\n  have eq' : y‚ÇÅ + y‚ÇÇ = y := eq\n  have : (f‚ÇÅ + f‚ÇÇ) y' ‚â• (f‚ÇÅ x + ‚ü™y‚ÇÅ, y' - x‚ü´) + (f‚ÇÇ x + ‚ü™y‚ÇÇ, y' - x‚ü´) := add_le_add (hy‚ÇÅ y') (hy‚ÇÇ y')\n  rwa [add_add_add_comm, ‚Üê inner_add_left, eq'] at this",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "_private",
        "theorem_statement": " {a : ‚Ñù} (h : ‚àÄ t > 0, 0 < a + t) : 0 ‚â§ a",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "Pointwise",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "private theorem leq_tendsto_zero {a : ‚Ñù} (h : ‚àÄ t > 0, 0 < a + t) : 0 ‚â§ a :=\n  by\n  by_contra h'; push_neg at h'; specialize h (-a / 2) (by linarith)\n  linarith",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt",
        "theorem_statement": " {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù} (h‚ÇÅ : ConvexOn ‚Ñù univ f‚ÇÅ) (h‚ÇÇ : ConvexOn ‚Ñù univ f‚ÇÇ) (hcon : ContinuousOn f‚ÇÅ univ) :\n  ‚àÄ (x : E), SubderivAt f‚ÇÅ x + SubderivAt f‚ÇÇ x = SubderivAt (f‚ÇÅ + f‚ÇÇ) x",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}",
            "variable [CompleteSpace E]"
        ],
        "namespaces": [
            "Pointwise",
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem add {f‚ÇÅ f‚ÇÇ : E ‚Üí ‚Ñù} (h‚ÇÅ : ConvexOn ‚Ñù univ f‚ÇÅ) (h‚ÇÇ : ConvexOn ‚Ñù univ f‚ÇÇ) (hcon : ContinuousOn f‚ÇÅ univ) :\n    ‚àÄ (x : E), SubderivAt f‚ÇÅ x + SubderivAt f‚ÇÇ x = SubderivAt (f‚ÇÅ + f‚ÇÇ) x :=\n  by\n  intro x‚ÇÄ\n  apply Subset.antisymm (SubderivAt.add_subset x‚ÇÄ)\n  rw [SubderivAt, SubderivAt, SubderivAt, Set.subset_def]\n  intro g hg\n  rw [Set.mem_setOf] at hg; rw [Set.mem_add]\n  let S‚ÇÅ := {(x, y) : E √ó ‚Ñù | y > f‚ÇÅ (x + x‚ÇÄ) - f‚ÇÅ x‚ÇÄ - inner g x}\n  let S‚ÇÇ := {(x, y) : E √ó ‚Ñù | y ‚â§ f‚ÇÇ x‚ÇÄ - f‚ÇÇ (x + x‚ÇÄ)}\n  have hs1 : Convex ‚Ñù S‚ÇÅ := by\n    rw [convex_iff_forall_pos]; intro i hi j hj a b ha hb hab\n    rw [Set.mem_setOf] at hi hj ‚ä¢; simp at hi hj ‚ä¢\n    rw [‚Üê mul_lt_mul_iff_of_pos_left ha] at hi\n    rw [‚Üê mul_lt_mul_iff_of_pos_left hb] at hj\n    rw [inner_add_right, inner_smul_right, inner_smul_right, ‚Üê sub_sub]\n    have : x‚ÇÄ = (1 : ‚Ñù) ‚Ä¢ x‚ÇÄ := by simp only [one_smul]\n    have : a ‚Ä¢ i.1 + b ‚Ä¢ j.1 + x‚ÇÄ = a ‚Ä¢ (i.1 + x‚ÇÄ) + b ‚Ä¢ (j.1 + x‚ÇÄ) := by nth_rw 1 [this];\n      rw [smul_add, smul_add, ‚Üê hab, add_smul]; rw [‚Üê add_assoc, ‚Üê add_assoc]; simp;\n      rw [add_assoc, add_comm (b ‚Ä¢ j.1), ‚Üê add_assoc]\n    have : f‚ÇÅ (a ‚Ä¢ i.1 + b ‚Ä¢ j.1 + x‚ÇÄ) ‚â§ a * f‚ÇÅ (i.1 + x‚ÇÄ) + b * f‚ÇÅ (j.1 + x‚ÇÄ) :=\n      by\n      rw [this]\n      rw [convexOn_iff_forall_pos] at h‚ÇÅ; rcases h‚ÇÅ with ‚ü®_, h‚ÇÅ‚ü©\n      specialize @h‚ÇÅ (i.1 + x‚ÇÄ) (by trivial) (j.1 + x‚ÇÄ) (by trivial) a b ha hb hab\n      simp at h‚ÇÅ; simp; linarith\n    apply lt_of_lt_of_le' (b := a * f‚ÇÅ (i.1 + x‚ÇÄ) + b * f‚ÇÅ (j.1 + x‚ÇÄ) - f‚ÇÅ x‚ÇÄ - a * ‚ü™g, i.1‚ü´_‚Ñù - b * ‚ü™g, j.1‚ü´_‚Ñù)\n    ¬∑ have : f‚ÇÅ x‚ÇÄ = (1 : ‚Ñù) ‚Ä¢ (f‚ÇÅ x‚ÇÄ) := by simp\n      rw [this, ‚Üê hab, add_smul, ‚Üê sub_sub, smul_eq_mul, smul_eq_mul]; linarith\n    ¬∑ simp [this];\n  have hs2 : Convex ‚Ñù S‚ÇÇ := by\n    rw [convex_iff_forall_pos]; intro i hi j hj a b ha hb hab\n    rw [Set.mem_setOf] at hi hj ‚ä¢; simp at hi hj ‚ä¢\n    rw [‚Üê mul_le_mul_iff_of_pos_left ha] at hi\n    rw [‚Üê mul_le_mul_iff_of_pos_left hb] at hj\n    have : x‚ÇÄ = (1 : ‚Ñù) ‚Ä¢ x‚ÇÄ := by simp only [one_smul]\n    have : a ‚Ä¢ i.1 + b ‚Ä¢ j.1 + x‚ÇÄ = a ‚Ä¢ (i.1 + x‚ÇÄ) + b ‚Ä¢ (j.1 + x‚ÇÄ) := by nth_rw 1 [this];\n      rw [smul_add, smul_add, ‚Üê hab, add_smul]; rw [‚Üê add_assoc, ‚Üê add_assoc]; simp;\n      rw [add_assoc, add_comm (b ‚Ä¢ j.1), ‚Üê add_assoc]\n    have ineq : f‚ÇÇ (a ‚Ä¢ i.1 + b ‚Ä¢ j.1 + x‚ÇÄ) ‚â§ a * f‚ÇÇ (i.1 + x‚ÇÄ) + b * f‚ÇÇ (j.1 + x‚ÇÄ) :=\n      by\n      rw [this]\n      rw [convexOn_iff_forall_pos] at h‚ÇÇ; rcases h‚ÇÇ with ‚ü®_, h‚ÇÇ‚ü©\n      specialize @h‚ÇÇ (i.1 + x‚ÇÄ) (by trivial) (j.1 + x‚ÇÄ) (by trivial) a b ha hb hab\n      simp at h‚ÇÇ; simp; linarith\n    have eq : f‚ÇÇ x‚ÇÄ = a * f‚ÇÇ x‚ÇÄ + b * f‚ÇÇ x‚ÇÄ := by rw [‚Üê add_mul, hab, one_mul]\n    obtain hh := sub_le_sub_left ineq (a * f‚ÇÇ x‚ÇÄ + b * f‚ÇÇ x‚ÇÄ)\n    have eq' :\n      a * (f‚ÇÇ x‚ÇÄ - f‚ÇÇ (i.1 + x‚ÇÄ)) + b * (f‚ÇÇ x‚ÇÄ - f‚ÇÇ (j.1 + x‚ÇÄ)) =\n        a * f‚ÇÇ x‚ÇÄ + b * f‚ÇÇ x‚ÇÄ - (a * f‚ÇÇ (i.1 + x‚ÇÄ) + b * f‚ÇÇ (j.1 + x‚ÇÄ)) :=\n      by ring\n    rw [‚Üê eq'] at hh; rw [eq]\n    apply le_trans (add_le_add hi hj) hh\n  have hint : Disjoint S‚ÇÅ S‚ÇÇ := by\n    rw [disjoint_iff]; by_contra joint\n    obtain ‚ü®‚ü®x, y‚ü©, ‚ü®hp1, hp2‚ü©‚ü© := nmem_singleton_empty.mp joint\n    rw [Set.mem_setOf] at hp1 hp2\n    specialize hg (x + x‚ÇÄ); rw [‚Üê add_sub, sub_self, add_zero] at hg\n    apply not_le_of_gt ?_ hg\n    obtain ineq := add_lt_add_of_le_of_lt hp2 (neg_lt_neg hp1)\n    simp at ineq\n    have hh : ‚àÄ x : E, (f‚ÇÅ + f‚ÇÇ) x = f‚ÇÅ x + f‚ÇÇ x := fun x => rfl\n    apply lt_of_sub_pos\n    have eq :\n      f‚ÇÇ x‚ÇÄ - f‚ÇÇ (x + x‚ÇÄ) + (‚ü™g, x‚ü´_‚Ñù - (f‚ÇÅ (x + x‚ÇÄ) - f‚ÇÅ x‚ÇÄ)) =\n        f‚ÇÅ x‚ÇÄ + f‚ÇÇ x‚ÇÄ + ‚ü™g, x‚ü´_‚Ñù - (f‚ÇÅ (x + x‚ÇÄ) + f‚ÇÇ (x + x‚ÇÄ)) :=\n      by ring\n    rwa [hh x‚ÇÄ, hh (x + x‚ÇÄ), ‚Üê eq]\n  have hso : IsOpen S‚ÇÅ :=\n    by\n    apply Continuous_epi_open (f‚ÇÅ := fun x ‚Ü¶ f‚ÇÅ (x + x‚ÇÄ) - f‚ÇÅ x‚ÇÄ - inner g x)\n    apply ContinuousOn.sub\n    ¬∑ apply ContinuousOn.sub\n      ¬∑ apply ContinuousOn.comp (g := f‚ÇÅ) (f := fun x ‚Ü¶ x + x‚ÇÄ) (t := univ) hcon\n        ¬∑ apply ContinuousOn.add continuousOn_id continuousOn_const\n        ¬∑ simp\n      apply continuousOn_const\n    apply ContinuousOn.inner continuousOn_const continuousOn_id\n  obtain ‚ü®f, c, ‚ü®hsl, hsr‚ü©‚ü© := geometric_hahn_banach_open hs1 hso hs2 hint\n  have eq : ‚àÉ a : E, ‚àÉ b : ‚Ñù, ‚àÄ (p : E √ó ‚Ñù), f p = inner a p.1 + b * p.2 :=\n    by\n    let f1 := ContinuousLinearMap.comp f (ContinuousLinearMap.inl ‚Ñù E ‚Ñù)\n    let f2 := ContinuousLinearMap.comp f (ContinuousLinearMap.inr ‚Ñù E ‚Ñù)\n    use (toDual ‚Ñù E).symm f1\n    use (toDual ‚Ñù ‚Ñù).symm f2\n    intro p\n    have : ((toDual ‚Ñù ‚Ñù).symm f2) * p.2 = inner (((toDual ‚Ñù ‚Ñù).symm f2)) p.2 := by simp [f2]\n    have : ((toDual ‚Ñù ‚Ñù).symm f2) * p.2 = f2 p.2 := by\n      rw [this]\n      simp only [toDual_symm_apply, ContinuousLinearMap.coe_comp', Function.comp_apply, ContinuousLinearMap.inl_apply,\n        ContinuousLinearMap.inr_apply]\n    rw [this]; simp [f1, f2]\n    have : (p.1, (0 : ‚Ñù)) + ((0 : E), p.2) = p := by simp\n    nth_rw 1 [‚Üê this]; rw [ContinuousLinearMap.map_add]\n  rcases eq with ‚ü®a, b, hab‚ü©\n  have hin : (0, 0) ‚àà S‚ÇÇ := by rw [Set.mem_setOf]; simp\n  obtain hc0 := hsr (0, 0) hin\n  rw [hab (0, 0)] at hc0; simp at hc0\n  have hin1 : ‚àÄ t > 0, (0, t) ‚àà S‚ÇÅ := by intro t ht; rw [Set.mem_setOf]; simp; linarith\n  have htp : ‚àÄ t > 0, b * t < c := by\n    intro t ht; obtain hin1 := hin1 t ht\n    specialize hsl (0, t) hin1; specialize hab (0, t); simp at hab\n    linarith\n  have ceq0 : c = 0 := by\n    by_contra hc; push_neg at hc; have hc : c < 0 := lt_of_le_of_ne hc0 hc\n    by_cases hb : b ‚â• 0\n    ¬∑ specialize htp 1 (by linarith); rw [mul_one] at htp\n      linarith\n    push_neg at hb\n    have pos : (c / (2 * b)) > 0 := by apply div_pos_of_neg_of_neg hc (by linarith)\n    specialize (htp (c / (2 * b)) pos); field_simp [hb] at htp\n    have eq : b * c / (2 * b) = c / 2 := by\n      ring_nf; simp; field_simp [hb]\n      rw [mul_div_right_comm, div_self (by linarith), one_mul]\n    rw [eq] at htp; linarith\n  have bleq0 : b < 0 := by\n    rw [ceq0] at htp\n    specialize htp 1 (by linarith); rw [mul_one] at htp; linarith\n  let hata := -(1 / b) ‚Ä¢ a\n  have g1 : g + hata ‚àà {g | HasSubgradientAt f‚ÇÅ g x‚ÇÄ} :=\n    by\n    rw [Set.mem_setOf]; unfold HasSubgradientAt; intro x\n    simp [hata]\n    have hin1 : ‚àÄ t > 0, (x - x‚ÇÄ, f‚ÇÅ x - f‚ÇÅ x‚ÇÄ - ‚ü™g, x - x‚ÇÄ‚ü´_‚Ñù + t) ‚àà S‚ÇÅ :=\n      by\n      intro t ht\n      rw [Set.mem_setOf]; simp; exact ht\n    have ineq : ‚àÄ t > 0, 0 < b‚Åª¬π * ‚ü™a, x - x‚ÇÄ‚ü´_‚Ñù + f‚ÇÅ x - f‚ÇÅ x‚ÇÄ - ‚ü™g, x - x‚ÇÄ‚ü´_‚Ñù + t :=\n      by\n      intro t ht\n      specialize hsl (x - x‚ÇÄ, f‚ÇÅ x - f‚ÇÅ x‚ÇÄ - ‚ü™g, x - x‚ÇÄ‚ü´_‚Ñù + t) (hin1 t ht)\n      rw [ceq0, hab (x - x‚ÇÄ, f‚ÇÅ x - f‚ÇÅ x‚ÇÄ - ‚ü™g, x - x‚ÇÄ‚ü´_‚Ñù + t)] at hsl; simp at hsl\n      obtain ineq := (mul_lt_mul_left_of_neg (inv_lt_zero.mpr bleq0)).mpr hsl\n      simp at ineq\n      rw [mul_add, ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ (ne_of_lt bleq0), one_mul] at ineq\n      rw [‚Üê add_assoc, add_sub, add_sub] at ineq; exact ineq\n    rw [inner_add_left, inner_neg_left, real_inner_smul_left]\n    rw [‚Üê add_assoc]; simp\n    have : b‚Åª¬π * ‚ü™a, x - x‚ÇÄ‚ü´_‚Ñù + f‚ÇÅ x - f‚ÇÅ x‚ÇÄ - ‚ü™g, x - x‚ÇÄ‚ü´_‚Ñù ‚â• 0 := leq_tendsto_zero ineq\n    linarith\n  have g2 : -hata ‚àà {g | HasSubgradientAt f‚ÇÇ g x‚ÇÄ} :=\n    by\n    rw [Set.mem_setOf]; unfold HasSubgradientAt; intro x\n    simp [hata]; have hin2 : (x - x‚ÇÄ, f‚ÇÇ x‚ÇÄ - f‚ÇÇ x) ‚àà S‚ÇÇ := by rw [Set.mem_setOf]; simp\n    specialize hsr (x - x‚ÇÄ, f‚ÇÇ x‚ÇÄ - f‚ÇÇ x) hin2\n    rw [ceq0, hab (x - x‚ÇÄ, f‚ÇÇ x‚ÇÄ - f‚ÇÇ x)] at hsr; simp at hsr\n    obtain ineq := (mul_le_mul_left_of_neg (inv_lt_zero.mpr bleq0)).mpr hsr\n    rw [mul_add, ‚Üê real_inner_smul_left, mul_zero, ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ (ne_of_lt bleq0), one_mul] at ineq\n    linarith\n  use (g + hata); constructor; exact g1\n  use (-hata); constructor; exact g2; simp",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt_of_norm_at_zero",
        "theorem_statement": " : SubderivAt (fun (x : E) => ‚Äñx‚Äñ) 0 = {g | ‚Äñg‚Äñ ‚â§ 1}",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem SubderivAt_of_norm_at_zero : SubderivAt (fun (x : E) => ‚Äñx‚Äñ) 0 = {g | ‚Äñg‚Äñ ‚â§ 1} :=\n  by\n  ext g\n  constructor\n  ¬∑ intro hg; by_contra h\n    have hg' : ‚Äñg‚Äñ > 1 := not_le.mp h\n    specialize hg g\n    simp only [sub_zero, norm_zero, zero_add, real_inner_self_eq_norm_mul_norm] at hg\n    have : ‚Äñg‚Äñ * ‚Äñg‚Äñ > 1 * ‚Äñg‚Äñ := mul_lt_mul_of_pos_right hg' (by linarith)\n    simp only [one_mul] at this\n    apply not_lt.mpr hg this\n  intro hg y\n  calc\n    ‚Äñ(0 : E)‚Äñ + inner g (y - 0) = inner g y := by simp only [norm_zero, zero_add, sub_zero]\n    _ ‚â§ ‚Äñg‚Äñ * ‚Äñy‚Äñ := (real_inner_le_norm g y)\n    _ ‚â§ 1 * ‚Äñy‚Äñ := (mul_le_mul_of_nonneg_right hg (norm_nonneg y))\n    _ = ‚Äñy‚Äñ := by simp only [one_mul]",
        "type": "theorem",
        "filename": "Subgradient"
    },
    {
        "theorem_name": "SubderivAt_abs",
        "theorem_statement": " (x : ‚Ñù) : SubderivAt abs x = if x = 0 then Icc (-1) 1 else {Real.sign x}",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ‚Ñù E]",
            "variable {f : E ‚Üí ‚Ñù}",
            "variable {g : E}",
            "variable {x : E}",
            "variable {s : Set E}"
        ],
        "namespaces": [
            "InnerProductSpace",
            "Set",
            "Topology",
            "Filter"
        ],
        "proof_process": "theorem SubderivAt_abs (x : ‚Ñù) : SubderivAt abs x = if x = 0 then Icc (-1) 1 else {Real.sign x} :=\n  by\n  rw [eq_ite_iff]\n  by_cases h : x = 0\n  ¬∑ left; constructor\n    ¬∑ exact h\n    have h2 : Icc (-1 : ‚Ñù) 1 = {g | ‚Äñg‚Äñ ‚â§ 1} := by\n      ext y; simp only [Icc, mem_setOf, norm]\n      have : |y| ‚â§ 1 ‚Üî -1 ‚â§ y ‚àß y ‚â§ 1 := by apply abs_le\n      exact (Iff.symm this)\n    rw [h2, h]\n    apply SubderivAt_of_norm_at_zero\n  right\n  constructor\n  ¬∑ exact h\n  ext g\n  constructor\n  ¬∑ intro hg\n    by_cases hx : x > 0\n    ¬∑ by_contra gne\n      by_cases glt : g < 1\n      ¬∑ specialize hg 0\n        have ineq : (0 : ‚Ñù) < 0 := by\n          calc\n            0 ‚â• x + g * (-x) := by\n              simp only [abs_zero, zero_sub, abs_pos_of_pos, abs_of_pos hx] at hg\n              have : inner g (-x) = g * (-x) := by rfl\n              rwa [this] at hg\n            _ = x * (1 - g) := by ring\n            _ > 0 := mul_pos hx (by linarith)\n        exact LT.lt.false ineq\n      specialize hg (x + 1)\n      have : x + 1 > 0 := by linarith\n      simp only [abs_of_pos hx, abs_of_pos this, add_le_add_iff_left, add_sub_cancel_left] at hg\n      apply glt\n      have h1 : g ‚â§ 1 := by\n        calc\n          g = inner g 1 := by simp\n          _ ‚â§ 1 := hg\n      simp only [Real.sign_of_pos hx] at gne\n      exact Ne.lt_of_le gne h1\n    have hx : x < 0 := Ne.lt_of_le h (not_lt.mp hx)\n    rw [Real.sign_of_neg hx]\n    by_contra gne\n    by_cases glt : g < -1\n    ¬∑ specialize hg (x - 1)\n      have : x - 1 < 0 := by linarith\n      simp only [abs_of_neg this, abs_of_neg hx, abs_zero, zero_sub] at hg\n      have : -g ‚â§ 1 := by\n        calc\n          -g = inner g (x - 1 - x) := by simp\n          _ ‚â§ 1 := by linarith [hg]\n      linarith\n    specialize hg 0\n    have eq1 : inner g (-x) = g * (-x) := rfl\n    have eq2 : -x + g * -x = -x * (1 + g) := by ring\n    simp only [abs_zero, zero_sub, abs_of_neg hx, eq1, eq2] at hg\n    have : -x * (1 + g) > 0 := by\n      apply mul_pos (by linarith)\n      have : g > -1 := Ne.lt_of_le' gne (not_lt.mp glt)\n      linarith\n    linarith\n  intro hg y\n  by_cases hx : x > 0\n  ¬∑ simp only [Real.sign_of_pos hx] at hg\n    calc\n      |x| + inner g (y - x) = x + inner 1 (y - x) := by rw [abs_of_pos hx, hg]\n      _ = y := by simp\n      _ ‚â§ |y| := le_abs_self y\n  have hx : x < 0 := Ne.lt_of_le h (not_lt.mp hx)\n  simp only [Real.sign_of_neg hx] at hg\n  calc\n    |x| + inner g (y - x) = -x + inner (-1) (y - x) := by rw [abs_of_neg hx, hg]\n    _ = -y := by simp; ring\n    _ ‚â§ |y| := neg_le_abs y",
        "type": "theorem",
        "filename": "Subgradient"
    }
]