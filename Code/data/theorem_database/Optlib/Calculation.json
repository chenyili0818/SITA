[
    {
        "theorem_name": "termâˆ‡",
        "theorem_statement": " : Lean.ParserDescrâœ",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "@[local term_parser 1000]\ndef termâˆ‡âœ : Lean.ParserDescrâœ :=\n  ParserDescr.nodeâœ\n    (Lean.Name.mkNumâœ (Lean.Name.mkStrâœ (Lean.Name.mkStrâœ (Lean.Name.mkStrâœ Lean.Name.anonymousâœ \"termâˆ‡\") \"_@\") \"_hyg\")\n      65)\n    1024 (ParserDescr.symbolâœ \"âˆ‡\")",
        "type": "definition",
        "filename": "Calculation"
    },
    {
        "theorem_name": "_aux___macroRules_termâˆ‡_1",
        "theorem_statement": " : Macroâœ",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "@[macro termâˆ‡âœ]\ndef Â«_aux___macroRules_termâˆ‡_1Â» : Macroâœ := fun\n  | `(âˆ‡) => ``(gradient)\n  | _ => no_error_if_unused% throwâœ Lean.Macro.Exception.unsupportedSyntaxâœ",
        "type": "definition",
        "filename": "Calculation"
    },
    {
        "theorem_name": "_aux___unexpand_gradient_1",
        "theorem_statement": " : Lean.PrettyPrinter.Unexpanderâœ",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "",
        "type": "definition",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (hg : HasGradientAtFilter g g' (f x) L') (hf : HasGradientAtFilter f f' x L) (hL : Tendsto f L L') :\n  HasGradientAtFilter (g âˆ˜ f) (g' â€¢ f') x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {g : ğ•œ â†’ ğ•œ}",
            "variable {g' : ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem comp (hg : HasGradientAtFilter g g' (f x) L') (hf : HasGradientAtFilter f f' x L) (hL : Tendsto f L L') :\n    HasGradientAtFilter (g âˆ˜ f) (g' â€¢ f') x L :=\n  by\n  have eq : (starRingEnd ğ•œ) g' â€¢ (toDual ğ•œ F) f' = (toDual ğ•œ F) (g' â€¢ f') := by rw [map_smulâ‚›â‚—]\n  rw [HasGradientAtFilter, â† eq]\n  exact hg.hasDerivAtFilter.comp_hasFDerivAtFilter x hf hL",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hg : HasGradientWithinAt g g' t (f x)) (hf : HasGradientWithinAt f f' s x) (hst : MapsTo f s t) :\n  HasGradientWithinAt (g âˆ˜ f) (g' â€¢ f') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {g : ğ•œ â†’ ğ•œ}",
            "variable {g' : ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem comp (hg : HasGradientWithinAt g g' t (f x)) (hf : HasGradientWithinAt f f' s x) (hst : MapsTo f s t) :\n    HasGradientWithinAt (g âˆ˜ f) (g' â€¢ f') s x :=\n  HasGradientAtFilter.comp hg hf <| hf.continuousWithinAt.tendsto_nhdsWithin hst",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hg : HasGradientAt g g' (f x)) (hf : HasGradientWithinAt f f' s x) : HasGradientWithinAt (g âˆ˜ f) (g' â€¢ f') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {g : ğ•œ â†’ ğ•œ}",
            "variable {g' : ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem comp_hasGradientWithinAt (hg : HasGradientAt g g' (f x)) (hf : HasGradientWithinAt f f' s x) :\n    HasGradientWithinAt (g âˆ˜ f) (g' â€¢ f') s x :=\n  hg.comp hf hf.continuousWithinAt",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hg : HasGradientWithinAt g g' t (f x)) (hf : HasGradientWithinAt f f' s x) (hst : Tendsto f (ğ“[s] x) (ğ“[t] f x)) :\n  HasGradientWithinAt (g âˆ˜ f) (g' â€¢ f') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {g : ğ•œ â†’ ğ•œ}",
            "variable {g' : ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem comp_of_mem (hg : HasGradientWithinAt g g' t (f x)) (hf : HasGradientWithinAt f f' s x)\n    (hst : Tendsto f (ğ“[s] x) (ğ“[t] f x)) : HasGradientWithinAt (g âˆ˜ f) (g' â€¢ f') s x :=\n  HasGradientAtFilter.comp hg hf hst",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hg : HasGradientAt g g' (f x)) (hf : HasGradientAt f f' x) : HasGradientAt (g âˆ˜ f) (g' â€¢ f') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {g : ğ•œ â†’ ğ•œ}",
            "variable {g' : ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "/-- The chain rule. -/\ntheorem comp (hg : HasGradientAt g g' (f x)) (hf : HasGradientAt f f' x) : HasGradientAt (g âˆ˜ f) (g' â€¢ f') x :=\n  HasGradientAtFilter.comp hg hf hf.continuousAt",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient",
        "theorem_statement": " (hg : DifferentiableAt ğ•œ g (f x)) (hf : DifferentiableAt ğ•œ f x) : âˆ‡ (g âˆ˜ f) x = (âˆ‡ g (f x)) â€¢ (âˆ‡ f x)",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {g : ğ•œ â†’ ğ•œ}",
            "variable {g' : ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem comp (hg : DifferentiableAt ğ•œ g (f x)) (hf : DifferentiableAt ğ•œ f x) : âˆ‡ (g âˆ˜ f) x = (âˆ‡ g (f x)) â€¢ (âˆ‡ f x) :=\n  (hg.hasGradientAt.comp hf.hasGradientAt).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (h : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun x => c â€¢ f x) ((starRingEnd ğ•œ) c â€¢ f') x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_smul (h : HasGradientAtFilter f f' x L) (c : ğ•œ) :\n    HasGradientAtFilter (fun x => c â€¢ f x) ((starRingEnd ğ•œ) c â€¢ f') x L :=\n  by\n  have : c â€¢ (toDual ğ•œ F) f' = (toDual ğ•œ F) ((starRingEnd ğ•œ) c â€¢ f') := by\n    rw [map_smulâ‚›â‚—, RingHomCompTriple.comp_apply, RingHom.id_apply]\n  rw [HasGradientAtFilter, â† this]; rw [HasGradientAtFilter] at h\n  exact h.const_smul c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (h : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun x => c â€¢ f x) ((starRingEnd ğ•œ) c â€¢ f') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_smul (h : HasGradientWithinAt f f' s x) (c : ğ•œ) :\n    HasGradientWithinAt (fun x => c â€¢ f x) ((starRingEnd ğ•œ) c â€¢ f') s x := by exact HasGradientAtFilter.const_smul h c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (h : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => c â€¢ f x) ((starRingEnd ğ•œ) c â€¢ f') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_smul (h : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => c â€¢ f x) ((starRingEnd ğ•œ) c â€¢ f') x :=\n  by exact HasGradientAtFilter.const_smul h c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_const_smul",
        "theorem_statement": " (h : DifferentiableAt ğ•œ f x) (c : ğ•œ) : âˆ‡ (fun y => c â€¢ f y) x = (starRingEnd ğ•œ) c â€¢ âˆ‡ f x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_const_smul (h : DifferentiableAt ğ•œ f x) (c : ğ•œ) : âˆ‡ (fun y => c â€¢ f y) x = (starRingEnd ğ•œ) c â€¢ âˆ‡ f x :=\n  (h.hasGradientAt.const_smul c).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (h : HasGradientAtFilter f f' x L) : HasGradientAtFilter (fun x => c â€¢ f x) (c â€¢ f') x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable [InnerProductSpace â„ F]",
            "variable {f : F â†’ â„}",
            "variable (c : â„)"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_smul' (h : HasGradientAtFilter f f' x L) : HasGradientAtFilter (fun x => c â€¢ f x) (c â€¢ f') x L :=\n  h.const_smul c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (h : HasGradientWithinAt f f' s x) : HasGradientWithinAt (fun x => c â€¢ f x) (c â€¢ f') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable [InnerProductSpace â„ F]",
            "variable {f : F â†’ â„}",
            "variable (c : â„)"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_smul' (h : HasGradientWithinAt f f' s x) : HasGradientWithinAt (fun x => c â€¢ f x) (c â€¢ f') s x := by\n  exact HasGradientWithinAt.const_smul h c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (h : HasGradientAt f f' x) : HasGradientAt (fun x => c â€¢ f x) (c â€¢ f') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable [InnerProductSpace â„ F]",
            "variable {f : F â†’ â„}",
            "variable (c : â„)"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_smul' (h : HasGradientAt f f' x) : HasGradientAt (fun x => c â€¢ f x) (c â€¢ f') x := by\n  exact HasGradientAt.const_smul h c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_const_smul'",
        "theorem_statement": " (h : DifferentiableAt â„ f x) (c : â„) : âˆ‡ (fun y => c â€¢ f y) x = c â€¢ âˆ‡ f x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable [InnerProductSpace â„ F]",
            "variable {f : F â†’ â„}",
            "variable (c : â„)"
        ],
        "namespaces": [
            "Filter",
            "Set",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_const_smul' (h : DifferentiableAt â„ f x) (c : â„) : âˆ‡ (fun y => c â€¢ f y) x = c â€¢ âˆ‡ f x :=\n  (h.hasGradientAt.const_smul c).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (hf : HasGradientAtFilter f f' x L) (hg : HasGradientAtFilter g g' x L) :\n  HasGradientAtFilter (fun y => f y + g y) (f' + g') x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem add (hf : HasGradientAtFilter f f' x L) (hg : HasGradientAtFilter g g' x L) :\n    HasGradientAtFilter (fun y => f y + g y) (f' + g') x L :=\n  by\n  rw [HasGradientAtFilter]; rw [HasGradientAtFilter] at hf hg\n  have : (toDual ğ•œ F) (f' + g') = (toDual ğ•œ F) f' + (toDual ğ•œ F) g' := by simp\n  rw [this]; exact hf.add hg",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hf : HasGradientWithinAt f f' s x) (hg : HasGradientWithinAt g g' s x) :\n  HasGradientWithinAt (fun y => f y + g y) (f' + g') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem add (hf : HasGradientWithinAt f f' s x) (hg : HasGradientWithinAt g g' s x) :\n    HasGradientWithinAt (fun y => f y + g y) (f' + g') s x := by exact HasGradientAtFilter.add hf hg",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hf : HasGradientAt f f' x) (hg : HasGradientAt g g' x) : HasGradientAt (fun x => f x + g x) (f' + g') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem add (hf : HasGradientAt f f' x) (hg : HasGradientAt g g' x) : HasGradientAt (fun x => f x + g x) (f' + g') x :=\n  by exact HasGradientAtFilter.add hf hg",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_add",
        "theorem_statement": " (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) : âˆ‡ (fun y => f y + g y) x = âˆ‡ f x + âˆ‡ g x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_add (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :\n    âˆ‡ (fun y => f y + g y) x = âˆ‡ f x + âˆ‡ g x :=\n  (hf.hasGradientAt.add hg.hasGradientAt).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (hf : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun y => f y + c) f' x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem add_const (hf : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun y => f y + c) f' x L :=\n  add_zero f' â–¸ hf.add (hasGradientAtFilter_const _ _ _)",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hf : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun y => f y + c) f' s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem add_const (hf : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun y => f y + c) f' s x := by\n  exact HasGradientAtFilter.add_const hf c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hf : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => f x + c) f' x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem add_const (hf : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => f x + c) f' x := by\n  exact HasGradientAtFilter.add_const hf c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_add_const",
        "theorem_statement": " (c : ğ•œ) : âˆ‡ (fun y => f y + c) x = âˆ‡ f x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_add_const (c : ğ•œ) : âˆ‡ (fun y => f y + c) x = âˆ‡ f x :=\n  by\n  unfold gradient\n  simp only [EmbeddingLike.apply_eq_iff_eq]\n  exact fderiv_add_const c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (hf : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun y => c + f y) f' x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_add (hf : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun y => c + f y) f' x L :=\n  zero_add f' â–¸ (hasGradientAtFilter_const _ _ _).add hf",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hf : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun y => c + f y) f' s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_add (hf : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun y => c + f y) f' s x := by\n  exact HasGradientAtFilter.const_add hf c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hf : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => c + f x) f' x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_add (hf : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => c + f x) f' x := by\n  exact HasGradientAtFilter.const_add hf c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "Gradient_const_add",
        "theorem_statement": " (c : ğ•œ) : âˆ‡ (fun y => c + f y) x = âˆ‡ f x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem Gradient_const_add (c : ğ•œ) : âˆ‡ (fun y => c + f y) x = âˆ‡ f x := by simp only [add_comm c, gradient_add_const]",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (h : âˆ€ i âˆˆ u, HasGradientAtFilter (A i) (A' i) x L) :\n  HasGradientAtFilter (fun y => âˆ‘ i in u, A i y) (âˆ‘ i in u, A' i) x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {Î¹ : Type*}",
            "variable {u : Finset Î¹}",
            "variable {A : Î¹ â†’ F â†’ ğ•œ}",
            "variable {A' : Î¹ â†’ F}"
        ],
        "namespaces": [
            "Asymptotics",
            "BigOperators",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sum (h : âˆ€ i âˆˆ u, HasGradientAtFilter (A i) (A' i) x L) :\n    HasGradientAtFilter (fun y => âˆ‘ i in u, A i y) (âˆ‘ i in u, A' i) x L :=\n  by\n  have : âˆ‘ i in u, (toDual ğ•œ F) (A' i) = (toDual ğ•œ F) (âˆ‘ i in u, A' i) := by rw [map_sum]\n  rw [HasGradientAtFilter, â† this]; unfold HasGradientAtFilter at h\n  exact HasFDerivAtFilter.sum h",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (h : âˆ€ i âˆˆ u, HasGradientWithinAt (A i) (A' i) s x) :\n  HasGradientWithinAt (fun y => âˆ‘ i in u, A i y) (âˆ‘ i in u, A' i) s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {Î¹ : Type*}",
            "variable {u : Finset Î¹}",
            "variable {A : Î¹ â†’ F â†’ ğ•œ}",
            "variable {A' : Î¹ â†’ F}"
        ],
        "namespaces": [
            "Asymptotics",
            "BigOperators",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sum (h : âˆ€ i âˆˆ u, HasGradientWithinAt (A i) (A' i) s x) :\n    HasGradientWithinAt (fun y => âˆ‘ i in u, A i y) (âˆ‘ i in u, A' i) s x := by exact HasGradientAtFilter.sum h",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (h : âˆ€ i âˆˆ u, HasGradientAt (A i) (A' i) x) : HasGradientAt (fun y => âˆ‘ i in u, A i y) (âˆ‘ i in u, A' i) x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {Î¹ : Type*}",
            "variable {u : Finset Î¹}",
            "variable {A : Î¹ â†’ F â†’ ğ•œ}",
            "variable {A' : Î¹ â†’ F}"
        ],
        "namespaces": [
            "Asymptotics",
            "BigOperators",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sum (h : âˆ€ i âˆˆ u, HasGradientAt (A i) (A' i) x) : HasGradientAt (fun y => âˆ‘ i in u, A i y) (âˆ‘ i in u, A' i) x :=\n  by exact HasGradientAtFilter.sum h",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_sum",
        "theorem_statement": " (h : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (A i) x) : âˆ‡ (fun y => âˆ‘ i in u, A i y) x = âˆ‘ i in u, âˆ‡ (A i) x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {Î¹ : Type*}",
            "variable {u : Finset Î¹}",
            "variable {A : Î¹ â†’ F â†’ ğ•œ}",
            "variable {A' : Î¹ â†’ F}"
        ],
        "namespaces": [
            "Asymptotics",
            "BigOperators",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_sum (h : âˆ€ i âˆˆ u, DifferentiableAt ğ•œ (A i) x) : âˆ‡ (fun y => âˆ‘ i in u, A i y) x = âˆ‘ i in u, âˆ‡ (A i) x :=\n  (HasGradientAt.sum fun i hi => (h i hi).hasGradientAt).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (h : HasGradientAtFilter f f' x L) : HasGradientAtFilter (fun x => -f x) (-f') x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem neg (h : HasGradientAtFilter f f' x L) : HasGradientAtFilter (fun x => -f x) (-f') x L :=\n  by\n  have : -(toDual ğ•œ F) f' = (toDual ğ•œ F) (-f') := by simp\n  rw [HasGradientAtFilter, â† this]; rw [HasGradientAtFilter] at h\n  exact h.neg",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (h : HasGradientWithinAt f f' s x) : HasGradientWithinAt (fun x => -f x) (-f') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem neg (h : HasGradientWithinAt f f' s x) : HasGradientWithinAt (fun x => -f x) (-f') s x := by\n  exact HasGradientAtFilter.neg h",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (h : HasGradientAt f f' x) : HasGradientAt (fun x => -f x) (-f') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem neg (h : HasGradientAt f f' x) : HasGradientAt (fun x => -f x) (-f') x := by exact HasGradientAtFilter.neg h",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_neg",
        "theorem_statement": " : âˆ‡ (fun y => -f y) x = -âˆ‡ f x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_neg : âˆ‡ (fun y => -f y) x = -âˆ‡ f x :=\n  by\n  unfold gradient\n  simp only [fderiv_neg, map_neg]",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (hf : HasGradientAtFilter f f' x L) (hg : HasGradientAtFilter g g' x L) :\n  HasGradientAtFilter (fun x => f x - g x) (f' - g') x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sub (hf : HasGradientAtFilter f f' x L) (hg : HasGradientAtFilter g g' x L) :\n    HasGradientAtFilter (fun x => f x - g x) (f' - g') x L := by simpa only [sub_eq_add_neg] using hf.add hg.neg",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hf : HasGradientWithinAt f f' s x) (hg : HasGradientWithinAt g g' s x) :\n  HasGradientWithinAt (fun x => f x - g x) (f' - g') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sub (hf : HasGradientWithinAt f f' s x) (hg : HasGradientWithinAt g g' s x) :\n    HasGradientWithinAt (fun x => f x - g x) (f' - g') s x := by exact HasGradientAtFilter.sub hf hg",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hf : HasGradientAt f f' x) (hg : HasGradientAt g g' x) : HasGradientAt (fun x => f x - g x) (f' - g') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sub (hf : HasGradientAt f f' x) (hg : HasGradientAt g g' x) : HasGradientAt (fun x => f x - g x) (f' - g') x :=\n  by exact HasGradientAtFilter.sub hf hg",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_sub",
        "theorem_statement": " (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) : âˆ‡ (fun y => f y - g y) x = âˆ‡ f x - âˆ‡ g x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_sub (hf : DifferentiableAt ğ•œ f x) (hg : DifferentiableAt ğ•œ g x) :\n    âˆ‡ (fun y => f y - g y) x = âˆ‡ f x - âˆ‡ g x :=\n  (hf.hasGradientAt.sub hg.hasGradientAt).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (hf : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun x => f x - c) f' x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sub_const (hf : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun x => f x - c) f' x L := by\n  simpa only [sub_eq_add_neg] using hf.add_const (-c)",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hf : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun x => f x - c) f' s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sub_const (hf : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun x => f x - c) f' s x := by\n  exact HasGradientAtFilter.sub_const hf c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hf : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => f x - c) f' x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem sub_const (hf : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => f x - c) f' x := by\n  exact HasGradientAtFilter.sub_const hf c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "Gradient_sub_const",
        "theorem_statement": " (c : ğ•œ) : âˆ‡ (fun y => f y - c) x = âˆ‡ f x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem Gradient_sub_const (c : ğ•œ) : âˆ‡ (fun y => f y - c) x = âˆ‡ f x := by simp only [sub_eq_add_neg, gradient_add_const]",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAtFilter",
        "theorem_statement": " (hf : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun x => c - f x) (-f') x L",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_sub (hf : HasGradientAtFilter f f' x L) (c : ğ•œ) : HasGradientAtFilter (fun x => c - f x) (-f') x L := by\n  simpa only [sub_eq_add_neg] using hf.neg.const_add c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hf : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun x => c - f x) (-f') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_sub (hf : HasGradientWithinAt f f' s x) (c : ğ•œ) : HasGradientWithinAt (fun x => c - f x) (-f') s x := by\n  exact HasGradientAtFilter.const_sub hf c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hf : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => c - f x) (-f') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_sub (hf : HasGradientAt f f' x) (c : ğ•œ) : HasGradientAt (fun x => c - f x) (-f') x := by\n  exact HasGradientAtFilter.const_sub hf c",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_const_sub",
        "theorem_statement": " (c : ğ•œ) : âˆ‡ (fun y => c - f y) x = -âˆ‡ f x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {f' : F}",
            "variable {g : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable {g' : F}",
            "variable {L : Filter F}",
            "variable {f : F â†’ ğ•œ}",
            "variable {L' : Filter ğ•œ}",
            "variable {t : Set ğ•œ}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_const_sub (c : ğ•œ) : âˆ‡ (fun y => c - f y) x = -âˆ‡ f x := by\n  calc\n    âˆ‡ (fun y => c - f y) x = âˆ‡ (fun y => -f y + c) x := by congr; ext x; rw [sub_eq_neg_add]\n    _ = -âˆ‡ f x := by rw [gradient_add_const c, gradient_neg]",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "equiv_lemma_mul",
        "theorem_statement": " :\n  c x â€¢ (toDual ğ•œ F) d' + d x â€¢ (toDual ğ•œ F) c' = (toDual ğ•œ F) ((starRingEnd ğ•œ) (c x) â€¢ d' + (starRingEnd ğ•œ) (d x) â€¢ c')",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ ğ•œ}",
            "variable {x : F}"
        ],
        "namespaces": [
            "ContinuousLinearMap",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem equiv_lemma_mul :\n    c x â€¢ (toDual ğ•œ F) d' + d x â€¢ (toDual ğ•œ F) c' =\n      (toDual ğ•œ F) ((starRingEnd ğ•œ) (c x) â€¢ d' + (starRingEnd ğ•œ) (d x) â€¢ c') :=\n  by\n  simp\n  congr <;> exact SemilinearMapClass.map_smul_inv _ _ _",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hc : HasGradientAt c c' x) (hd : HasGradientAt d d' x) :\n  HasGradientAt (fun y => c y * d y) ((starRingEnd ğ•œ) (c x) â€¢ d' + (starRingEnd ğ•œ) (d x) â€¢ c') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ ğ•œ}",
            "variable {x : F}"
        ],
        "namespaces": [
            "ContinuousLinearMap",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem mul (hc : HasGradientAt c c' x) (hd : HasGradientAt d d' x) :\n    HasGradientAt (fun y => c y * d y) ((starRingEnd ğ•œ) (c x) â€¢ d' + (starRingEnd ğ•œ) (d x) â€¢ c') x :=\n  by\n  rw [hasGradientAt_iff_hasFDerivAt, â† equiv_lemma_mul]\n  rw [hasGradientAt_iff_hasFDerivAt] at hc hd\n  exact hc.mul hd",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hc : HasGradientWithinAt c c' s x) (hd : HasGradientWithinAt d d' s x) :\n  HasGradientWithinAt (fun y => c y * d y) ((starRingEnd ğ•œ) (c x) â€¢ d' + (starRingEnd ğ•œ) (d x) â€¢ c') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ ğ•œ}",
            "variable {x : F}"
        ],
        "namespaces": [
            "ContinuousLinearMap",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem mul (hc : HasGradientWithinAt c c' s x) (hd : HasGradientWithinAt d d' s x) :\n    HasGradientWithinAt (fun y => c y * d y) ((starRingEnd ğ•œ) (c x) â€¢ d' + (starRingEnd ğ•œ) (d x) â€¢ c') s x :=\n  by\n  rw [hasGradientWithinAt_iff_hasFDerivWithinAt, â† equiv_lemma_mul]\n  rw [hasGradientWithinAt_iff_hasFDerivWithinAt] at hc hd\n  exact hc.mul hd",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_mul",
        "theorem_statement": " (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :\n  âˆ‡ (fun y => c y * d y) x = (starRingEnd ğ•œ) (c x) â€¢ âˆ‡ d x + (starRingEnd ğ•œ) (d x) â€¢ âˆ‡ c x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ ğ•œ}",
            "variable {x : F}"
        ],
        "namespaces": [
            "ContinuousLinearMap",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_mul (hc : DifferentiableAt ğ•œ c x) (hd : DifferentiableAt ğ•œ d x) :\n    âˆ‡ (fun y => c y * d y) x = (starRingEnd ğ•œ) (c x) â€¢ âˆ‡ d x + (starRingEnd ğ•œ) (d x) â€¢ âˆ‡ c x :=\n  (hc.hasGradientAt.mul hd.hasGradientAt).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hc : HasGradientAt c c' x) (hd : HasGradientAt d d' x) :\n  HasGradientAt (fun y => c y * d y) ((c x) â€¢ d' + (d x) â€¢ c') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable [InnerProductSpace â„ F]",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ â„}",
            "variable {x : F}"
        ],
        "namespaces": [
            "ContinuousLinearMap",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem mul' (hc : HasGradientAt c c' x) (hd : HasGradientAt d d' x) :\n    HasGradientAt (fun y => c y * d y) ((c x) â€¢ d' + (d x) â€¢ c') x :=\n  HasGradientAt.mul hc hd",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hc : HasGradientWithinAt c c' s x) (hd : HasGradientWithinAt d d' s x) :\n  HasGradientWithinAt (fun y => c y * d y) ((c x) â€¢ d' + (d x) â€¢ c') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable [InnerProductSpace â„ F]",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ â„}",
            "variable {x : F}"
        ],
        "namespaces": [
            "ContinuousLinearMap",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem mul' (hc : HasGradientWithinAt c c' s x) (hd : HasGradientWithinAt d d' s x) :\n    HasGradientWithinAt (fun y => c y * d y) ((c x) â€¢ d' + (d x) â€¢ c') s x :=\n  hc.mul hd",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_mul'",
        "theorem_statement": " (hc : DifferentiableAt â„ c x) (hd : DifferentiableAt â„ d x) : âˆ‡ (fun y => c y * d y) x = (c x) â€¢ âˆ‡ d x + (d x) â€¢ âˆ‡ c x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable [InnerProductSpace â„ F]",
            "variable {a' b' c' d' : F}",
            "variable {a b c d : F â†’ â„}",
            "variable {x : F}"
        ],
        "namespaces": [
            "ContinuousLinearMap",
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_mul' (hc : DifferentiableAt â„ c x) (hd : DifferentiableAt â„ d x) :\n    âˆ‡ (fun y => c y * d y) x = (c x) â€¢ âˆ‡ d x + (d x) â€¢ âˆ‡ c x :=\n  gradient_mul hc hd",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "equiv_lemma_mul_const",
        "theorem_statement": " : d â€¢ (toDual ğ•œ F) c' = (toDual ğ•œ F) ((starRingEnd ğ•œ) d â€¢ c')",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem equiv_lemma_mul_const : d â€¢ (toDual ğ•œ F) c' = (toDual ğ•œ F) ((starRingEnd ğ•œ) d â€¢ c') := by\n  rw [map_smulâ‚›â‚—, RingHomCompTriple.comp_apply, RingHom.id_apply]",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hc : HasGradientWithinAt c c' s x) : HasGradientWithinAt (fun y => c y * d) ((starRingEnd ğ•œ) d â€¢ c') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem mul_const (hc : HasGradientWithinAt c c' s x) :\n    HasGradientWithinAt (fun y => c y * d) ((starRingEnd ğ•œ) d â€¢ c') s x :=\n  by\n  rw [hasGradientWithinAt_iff_hasFDerivWithinAt, â† equiv_lemma_mul_const]\n  rw [hasGradientWithinAt_iff_hasFDerivWithinAt] at hc\n  exact hc.mul_const d",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hc : HasGradientAt c c' x) : HasGradientAt (fun y => c y * d) ((starRingEnd ğ•œ) d â€¢ c') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem mul_const (hc : HasGradientAt c c' x) : HasGradientAt (fun y => c y * d) ((starRingEnd ğ•œ) d â€¢ c') x :=\n  by\n  rw [hasGradientAt_iff_hasFDerivAt, â† equiv_lemma_mul_const]\n  rw [hasGradientAt_iff_hasFDerivAt] at hc\n  exact hc.mul_const d",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_mul_const",
        "theorem_statement": " (hc : DifferentiableAt ğ•œ c x) : âˆ‡ (fun y => c y * d) x = (starRingEnd ğ•œ) d â€¢ âˆ‡ c x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_mul_const (hc : DifferentiableAt ğ•œ c x) : âˆ‡ (fun y => c y * d) x = (starRingEnd ğ•œ) d â€¢ âˆ‡ c x :=\n  (hc.hasGradientAt.mul_const d).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "equiv_lemma_const_mul",
        "theorem_statement": " : b â€¢ (toDual ğ•œ F) a' = (toDual ğ•œ F) ((starRingEnd ğ•œ) b â€¢ a')",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem equiv_lemma_const_mul : b â€¢ (toDual ğ•œ F) a' = (toDual ğ•œ F) ((starRingEnd ğ•œ) b â€¢ a') := by\n  rw [map_smulâ‚›â‚—, RingHomCompTriple.comp_apply, RingHom.id_apply]",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (ha : HasGradientWithinAt a a' s x) : HasGradientWithinAt (fun y => b * a y) ((starRingEnd ğ•œ) b â€¢ a') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_mul (ha : HasGradientWithinAt a a' s x) :\n    HasGradientWithinAt (fun y => b * a y) ((starRingEnd ğ•œ) b â€¢ a') s x :=\n  by\n  rw [hasGradientWithinAt_iff_hasFDerivWithinAt, â† equiv_lemma_const_mul]\n  rw [hasGradientWithinAt_iff_hasFDerivWithinAt] at ha\n  exact ha.const_mul b",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (ha : HasGradientAt a a' x) : HasGradientAt (fun y => b * a y) ((starRingEnd ğ•œ) b â€¢ a') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_mul (ha : HasGradientAt a a' x) : HasGradientAt (fun y => b * a y) ((starRingEnd ğ•œ) b â€¢ a') x :=\n  by\n  rw [hasGradientAt_iff_hasFDerivAt, â† equiv_lemma_const_mul]\n  rw [hasGradientAt_iff_hasFDerivAt] at ha\n  exact ha.const_mul b",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_const_mul",
        "theorem_statement": " (ha : DifferentiableAt ğ•œ a x) : âˆ‡ (fun y => b * a y) x = (starRingEnd ğ•œ) b â€¢ âˆ‡ a x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_const_mul (ha : DifferentiableAt ğ•œ a x) : âˆ‡ (fun y => b * a y) x = (starRingEnd ğ•œ) b â€¢ âˆ‡ a x :=\n  (ha.hasGradientAt.const_mul b).gradient",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (hc : HasGradientWithinAt c c' s x) : HasGradientWithinAt (fun y => c y * d) (d â€¢ c') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)",
            "variable [InnerProductSpace â„ F]",
            "variable {c' a' : F}",
            "variable {c a : F â†’ â„}",
            "variable {x : F}",
            "variable (d b : â„)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem mul_const' (hc : HasGradientWithinAt c c' s x) : HasGradientWithinAt (fun y => c y * d) (d â€¢ c') s x :=\n  HasGradientWithinAt.mul_const d hc",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (hc : HasGradientAt c c' x) : HasGradientAt (fun y => c y * d) (d â€¢ c') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)",
            "variable [InnerProductSpace â„ F]",
            "variable {c' a' : F}",
            "variable {c a : F â†’ â„}",
            "variable {x : F}",
            "variable (d b : â„)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem mul_const' (hc : HasGradientAt c c' x) : HasGradientAt (fun y => c y * d) (d â€¢ c') x :=\n  HasGradientAt.mul_const d hc",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_mul_const'",
        "theorem_statement": " (hc : DifferentiableAt â„ c x) : âˆ‡ (fun y => c y * d) x = d â€¢ âˆ‡ c x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)",
            "variable [InnerProductSpace â„ F]",
            "variable {c' a' : F}",
            "variable {c a : F â†’ â„}",
            "variable {x : F}",
            "variable (d b : â„)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_mul_const' (hc : DifferentiableAt â„ c x) : âˆ‡ (fun y => c y * d) x = d â€¢ âˆ‡ c x :=\n  gradient_mul_const d hc",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientWithinAt",
        "theorem_statement": " (ha : HasGradientWithinAt a a' s x) : HasGradientWithinAt (fun y => b * a y) (b â€¢ a') s x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)",
            "variable [InnerProductSpace â„ F]",
            "variable {c' a' : F}",
            "variable {c a : F â†’ â„}",
            "variable {x : F}",
            "variable (d b : â„)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_mul' (ha : HasGradientWithinAt a a' s x) : HasGradientWithinAt (fun y => b * a y) (b â€¢ a') s x :=\n  HasGradientWithinAt.const_mul b ha",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "HasGradientAt",
        "theorem_statement": " (ha : HasGradientAt a a' x) : HasGradientAt (fun y => b * a y) (b â€¢ a') x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)",
            "variable [InnerProductSpace â„ F]",
            "variable {c' a' : F}",
            "variable {c a : F â†’ â„}",
            "variable {x : F}",
            "variable (d b : â„)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem const_mul' (ha : HasGradientAt a a' x) : HasGradientAt (fun y => b * a y) (b â€¢ a') x :=\n  HasGradientAt.const_mul b ha",
        "type": "theorem",
        "filename": "Calculation"
    },
    {
        "theorem_name": "gradient_const_mul'",
        "theorem_statement": " (ha : DifferentiableAt â„ a x) : âˆ‡ (fun y => b * a y) x = b â€¢ âˆ‡ a x",
        "variable": [
            "variable {ğ•œ F : Type*}",
            "variable [RCLike ğ•œ]",
            "variable [NormedAddCommGroup F]",
            "variable [InnerProductSpace ğ•œ F]",
            "variable [CompleteSpace F]",
            "variable {f : F â†’ ğ•œ}",
            "variable {f' x : F}",
            "variable {L : Filter F}",
            "variable {s : Set F}",
            "variable {c' a' : F}",
            "variable {c a : F â†’ ğ•œ}",
            "variable {x : F}",
            "variable (d b : ğ•œ)",
            "variable [InnerProductSpace â„ F]",
            "variable {c' a' : F}",
            "variable {c a : F â†’ â„}",
            "variable {x : F}",
            "variable (d b : â„)"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Topology"
        ],
        "proof_process": "theorem gradient_const_mul' (ha : DifferentiableAt â„ a x) : âˆ‡ (fun y => b * a y) x = b â€¢ âˆ‡ a x :=\n  gradient_const_mul b ha",
        "type": "theorem",
        "filename": "Calculation"
    }
]