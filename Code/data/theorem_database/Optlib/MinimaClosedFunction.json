[
    {
        "theorem_name": "_private",
        "theorem_statement": " {f : E â†’ F} (y : F) (h : (f â»Â¹' Set.Iic y).Nonempty) : sInf ({f x | x âˆˆ f â»Â¹' Set.Iic y}) = sInf {f x | x : E}",
        "variable": [
            "variable {E F : Type*}",
            "variable {E F : Type*}",
            "variable [CompleteLinearOrder F]"
        ],
        "namespaces": [
            "TopologicalSpace",
            "Filter",
            "Topology",
            "Bornology",
            "Set"
        ],
        "proof_process": "private theorem l0 {f : E â†’ F} (y : F) (h : (f â»Â¹' Set.Iic y).Nonempty) :\n    sInf ({f x | x âˆˆ f â»Â¹' Set.Iic y}) = sInf {f x | x : E} :=\n  by\n  have hâ‚€ : {f x | x : E} = {f x | x âˆˆ f â»Â¹' Set.Iic y} âˆª {f x | x âˆˆ (f â»Â¹' Set.Iic y)á¶œ} :=\n    by\n    ext y'; constructor\n    Â· rintro âŸ¨x, xeqâŸ©\n      by_cases xsub : x âˆˆ f â»Â¹' Set.Iic y\n      Â· exact Or.inl âŸ¨x, xsub, xeqâŸ©\n      Â· exact Or.inr âŸ¨x, xsub, xeqâŸ©\n    Â· intro h'\n      rcases h' with âŸ¨x, _, xeqâŸ© | âŸ¨x, _, xeqâŸ©\n      Â· exact Exists.intro x xeq\n      Â· exact Exists.intro x xeq\n  have hâ‚ : sInf ({f x | x âˆˆ f â»Â¹' Set.Iic y}) â‰¤ sInf ({f x | x âˆˆ (f â»Â¹' Set.Iic y)á¶œ}) :=\n    by\n    apply sInf_le_sInf_of_forall_exists_le\n    intro y' ynsub\n    rcases h with âŸ¨x', xsubâŸ©; use f x'\n    constructor\n    Â· exact âŸ¨x', xsub, rflâŸ©\n    rcases ynsub with âŸ¨x, xnsub, xeqâŸ©\n    apply le_trans xsub (Eq.trans_ge xeq (le_of_lt _))\n    simp only [â† Set.preimage_setOf_eq, â† Set.preimage_compl, Set.compl_Iic, Set.Ioi_def] at xnsub\n    assumption\n  calc\n    sInf ({f x | x âˆˆ f â»Â¹' Set.Iic y}) = sInf ({f x | x âˆˆ f â»Â¹' Set.Iic y}) âŠ“ sInf ({f x | x âˆˆ (f â»Â¹' Set.Iic y)á¶œ}) :=\n      Iff.mpr left_eq_inf hâ‚\n    _ = sInf ({f x | x âˆˆ f â»Â¹' Set.Iic y} âˆª {f x | x âˆˆ (f â»Â¹' Set.Iic y)á¶œ}) := (Eq.symm sInf_union)\n    _ = sInf {f x | x : E} := congrArg sInf (id (Eq.symm hâ‚€))",
        "type": "theorem",
        "filename": "MinimaClosedFunction"
    },
    {
        "theorem_name": "IsMinOn",
        "theorem_statement": " (hf : LowerSemicontinuous f) {y : F} (h1 : (f â»Â¹' Set.Iic y).Nonempty) (h2 : IsCompact (f â»Â¹' Set.Iic y)) :\n  âˆƒ x, IsMinOn f univ x",
        "variable": [
            "variable {E F : Type*}",
            "variable [CompleteLinearOrder F]",
            "variable [DenselyOrdered F]",
            "variable {f : E â†’ F}",
            "variable [TopologicalSpace E]",
            "variable [TopologicalSpace F]",
            "variable [OrderTopology F]",
            "variable [FirstCountableTopology E]",
            "variable\n  [FirstCountableTopology F]\n    /- If a premiage of `f` is nonempty and compact,\n      then its minimum point set `{x | IsMinOn f univ x}` is nonempty -/"
        ],
        "namespaces": [
            "TopologicalSpace",
            "Filter",
            "Topology",
            "Bornology",
            "Set"
        ],
        "proof_process": "theorem of_isCompact_preimage (hf : LowerSemicontinuous f) {y : F} (h1 : (f â»Â¹' Set.Iic y).Nonempty)\n    (h2 : IsCompact (f â»Â¹' Set.Iic y)) : âˆƒ x, IsMinOn f univ x :=\n  by\n  have hs : Set.Nonempty ({f x | x âˆˆ (f â»Â¹' Set.Iic y)}) :=\n    by\n    rcases h1 with âŸ¨x, xsubâŸ©\n    exact Exists.intro (f x) (Exists.intro x âŸ¨xsub, rflâŸ©)\n  have hs' : BddBelow ({f x | x âˆˆ (f â»Â¹' Set.Iic y)}) := OrderBot.bddBelow {x | âˆƒ x_1 âˆˆ f â»Â¹' Iic y, f x_1 = x}\n  rcases exists_seq_tendsto_sInf hs hs' with âŸ¨fx, _, cfx, fxsâŸ©\n  choose x xsub xeq using fxs\n  rcases IsCompact.tendsto_subseq h2 xsub with âŸ¨x', xsub', k, mono, cxkâŸ©\n  have cfxk : Tendsto (f âˆ˜ x âˆ˜ k) atTop (ğ“ (sInf ({f x | x âˆˆ (f â»Â¹' Set.Iic y)}))) :=\n    by\n    have xkeq : âˆ€ (n : â„•), (f âˆ˜ x âˆ˜ k) n = (fx âˆ˜ k) n := fun n => xeq <| k n\n    rw [tendsto_congr xkeq]\n    apply Tendsto.comp cfx (StrictMono.tendsto_atTop mono)\n  have inepi : (x', sInf ({f x | x âˆˆ (f â»Â¹' Set.Iic y)})) âˆˆ {p : E Ã— F | f p.1 â‰¤ p.2} :=\n    (IsClosed.isSeqClosed (LowerSemicontinuous.isClosed_epigraph hf)) (fun n => Eq.le (by rfl))\n      (Tendsto.prod_mk_nhds cxk cfxk)\n  use x'; intro xx _\n  apply le_of_eq_of_le\n  Â· apply le_antisymm inepi (sInf_le (Exists.intro x' âŸ¨xsub', rflâŸ©))\n  Â·\n    apply\n      le_of_eq_of_le (l0 y h1)\n        (sInf_le (by use xx))\n          /- If a premiage of `f` is nonempty and compact,\n            then its minimum point set `{x | IsMinOn f univ x}` is compact -/",
        "type": "theorem",
        "filename": "MinimaClosedFunction"
    },
    {
        "theorem_name": "IsCompact_isMinOn_of_isCompact_preimage",
        "theorem_statement": " (hf : LowerSemicontinuous f) {y : F} (h1 : (f â»Â¹' Set.Iic y).Nonempty) (h2 : IsCompact (f â»Â¹' Set.Iic y)) :\n  IsCompact {x | IsMinOn f univ x}",
        "variable": [
            "variable {E F : Type*}",
            "variable [CompleteLinearOrder F]",
            "variable [DenselyOrdered F]",
            "variable {f : E â†’ F}",
            "variable [TopologicalSpace E]",
            "variable [TopologicalSpace F]",
            "variable [OrderTopology F]",
            "variable [FirstCountableTopology E]",
            "variable\n  [FirstCountableTopology F]\n    /- If a premiage of `f` is nonempty and compact,\n      then its minimum point set `{x | IsMinOn f univ x}` is nonempty -/"
        ],
        "namespaces": [
            "TopologicalSpace",
            "Filter",
            "Topology",
            "Bornology",
            "Set"
        ],
        "proof_process": "theorem IsCompact_isMinOn_of_isCompact_preimage (hf : LowerSemicontinuous f) {y : F} (h1 : (f â»Â¹' Set.Iic y).Nonempty)\n    (h2 : IsCompact (f â»Â¹' Set.Iic y)) : IsCompact {x | IsMinOn f univ x} :=\n  by\n  obtain âŸ¨x', hx'âŸ© := IsMinOn.of_isCompact_preimage hf h1 h2\n  have seq : {x | IsMinOn f univ x} = (f â»Â¹' Set.Iic (f x')) :=\n    Set.ext fun xx =>\n      { mp := fun hxx => isMinOn_iff.mp hxx x' trivial, mpr := fun hxx x xuniv => ge_trans (hx' xuniv) hxx }\n  simp only [seq]\n  apply IsCompact.of_isClosed_subset h2 (LowerSemicontinuous.isClosed_preimage hf (f x'))\n  apply Set.preimage_mono\n  simp only [Set.Iic_subset_Iic]\n  obtain âŸ¨x, hxâŸ© := h1\n  exact ge_trans hx (hx' trivial)",
        "type": "theorem",
        "filename": "MinimaClosedFunction"
    },
    {
        "theorem_name": "strong_quasi",
        "theorem_statement": " (f : E â†’ F) (ğ•œ : Type _) [LinearOrderedRing ğ•œ] [Module ğ•œ E] : Prop",
        "variable": [
            "variable {E F : Type*}",
            "variable {ğ•œ : Type _}",
            "variable {f : E â†’ F}",
            "variable [AddCommMonoid E]",
            "variable [CompleteLinearOrder F]",
            "variable [LinearOrderedRing ğ•œ]",
            "variable [DenselyOrdered ğ•œ]",
            "variable [Module ğ•œ E]"
        ],
        "namespaces": [
            "TopologicalSpace",
            "Filter",
            "Topology",
            "Bornology",
            "Set"
        ],
        "proof_process": "def strong_quasi (f : E â†’ F) (ğ•œ : Type _) [LinearOrderedRing ğ•œ] [Module ğ•œ E] : Prop :=\n  âˆ€ â¦ƒxâ¦„,\n    âˆ€ â¦ƒyâ¦„,\n      x â‰  y â†’\n        âˆ€ â¦ƒa b : ğ•œâ¦„,\n          0 < a â†’\n            0 < b â†’\n              a + b = 1 â†’\n                f ((a â€¢ x : E) + (b â€¢ y : E)) <\n                  max (f x)\n                    (f y)\n                      /- the Minimum of strongly quasi function is unique -/",
        "type": "definition",
        "filename": "MinimaClosedFunction"
    },
    {
        "theorem_name": "isMinOn_unique",
        "theorem_statement": " {x y : E} (hf' : strong_quasi f ğ•œ) (hx : IsMinOn f univ x) (hy : IsMinOn f univ y) : x = y",
        "variable": [
            "variable {E F : Type*}",
            "variable {ğ•œ : Type _}",
            "variable {f : E â†’ F}",
            "variable [AddCommMonoid E]",
            "variable [CompleteLinearOrder F]",
            "variable [LinearOrderedRing ğ•œ]",
            "variable [DenselyOrdered ğ•œ]",
            "variable [Module ğ•œ E]"
        ],
        "namespaces": [
            "TopologicalSpace",
            "Filter",
            "Topology",
            "Bornology",
            "Set"
        ],
        "proof_process": "theorem isMinOn_unique {x y : E} (hf' : strong_quasi f ğ•œ) (hx : IsMinOn f univ x) (hy : IsMinOn f univ y) : x = y :=\n  by\n  by_contra neq\n  have : (0 : ğ•œ) < (1 : ğ•œ) := one_pos\n  obtain âŸ¨a, lta, altâŸ© := exists_between this\n  have eqone : a + (1 - a) = 1 := add_sub_cancel a 1\n  have lta' : 0 < 1 - a := sub_pos_of_lt alt\n  have h : f (a â€¢ x + (1 - a) â€¢ y) < f y :=\n    by\n    apply Eq.trans_gt (max_eq_right (hx trivial))\n    apply hf' neq lta lta' eqone\n  simp only [isMinOn_iff] at hy\n  specialize hy (a â€¢ x + (1 - a) â€¢ y) trivial\n  apply not_le_of_lt h hy",
        "type": "theorem",
        "filename": "MinimaClosedFunction"
    }
]