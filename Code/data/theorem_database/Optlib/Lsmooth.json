[
    {
        "theorem_name": "lipschitz_continuous_upper_bound",
        "theorem_statement": " {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] {f : E → ℝ} {f' : E → (E →L[ℝ] ℝ)} {l : NNReal}\n  (hd : ∀ x : E, HasFDerivAt f (f' x) x) (hl : LipschitzWith l f') :\n  ∀ (x y : E), f y ≤ f x + (f' x) (y - x) + l / 2 * ‖y - x‖ ^ 2",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lipschitz_continuous_upper_bound {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] {f : E → ℝ}\n    {f' : E → (E →L[ℝ] ℝ)} {l : NNReal} (hd : ∀ x : E, HasFDerivAt f (f' x) x) (hl : LipschitzWith l f') :\n    ∀ (x y : E), f y ≤ f x + (f' x) (y - x) + l / 2 * ‖y - x‖ ^ 2 :=\n  by\n  intro x y; rw [lipschitzWith_iff_norm_sub_le] at hl\n  let g := fun t : ℝ ↦ f (x + t • (y - x))\n  let g' := fun t : ℝ ↦ (f' (x + t • (y - x)) (y - x))\n  let LL := l * ‖y - x‖ ^ 2\n  obtain gderiv : ∀ t₀ : ℝ, HasDerivAt g (g' t₀) t₀ := deriv_function_comp_segment x y hd\n  have glip : ∀ u v : ℝ, ‖g' u - g' v‖ ≤ l * ‖y - x‖ ^ 2 * ‖u - v‖ :=\n    by\n    intro u v\n    calc\n      _ ≤ ‖f' (x + u • (y - x)) - f' (x + v • (y - x))‖ * ‖y - x‖ := ContinuousLinearMap.le_opNorm _ (y - x)\n      _ ≤ l * ‖x + u • (y - x) - (x + v • (y - x))‖ * ‖y - x‖ :=\n        (mul_le_mul_of_nonneg (hl _ _) (le_refl _) (norm_nonneg _) (norm_nonneg _))\n      _ = l * ‖y - x‖ ^ 2 * ‖u - v‖ := by rw [← sub_sub, add_sub_right_comm, sub_self, zero_add, ← sub_smul, norm_smul];\n        ring_nf\n  let u := fun t₀ : ℝ ↦ g 0 + t₀ * (g' 0) + t₀ ^ 2 * (LL / 2)\n  let u' := fun t : ℝ ↦ g' 0 + LL * t\n  have hderiv : ∀ t, HasDerivAt u (u' t) t := by\n    intro t\n    apply HasDerivAt.add\n    · apply HasDerivAt.const_add\n      · apply hasDerivAt_mul_const\n    · have : l * ‖y - x‖ ^ 2 * t = (2 * t) * (l * ‖y - x‖ ^ 2 / 2) := by field_simp; ring_nf\n      rw [this]; apply HasDerivAt.mul_const\n      obtain hd := HasDerivAt.pow (n := 2) (hasDerivAt_id' t)\n      simp at hd; exact hd\n  suffices g 1 ≤ u 1 by\n    simp [u, g, u', LL, g'] at this\n    rw [map_sub]; linarith\n  apply image_le_of_deriv_right_le_deriv_boundary (a := 0) (b := 2)\n  · exact HasDerivAt.continuousOn (fun x _ ↦ gderiv x)\n  · exact fun t _ ↦ HasDerivAt.hasDerivWithinAt (gderiv t)\n  · simp [u]\n  · exact HasDerivAt.continuousOn (fun x _ ↦ hderiv x)\n  · exact fun t _ ↦ HasDerivAt.hasDerivWithinAt (hderiv t)\n  · intro t ht\n    simp [u', LL]; simp at ht\n    apply tsub_le_iff_left.mp\n    apply le_trans (le_abs_self _)\n    convert (glip t 0); simp; rw [abs_of_nonneg ht.1]\n  simp\n    -- end",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "lower_to_lipschitz",
        "theorem_statement": " (h₂ : ∀ x y, inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2) (hl : l > 0) : LipschitzWith l f'",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lower_to_lipschitz (h₂ : ∀ x y, inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2) (hl : l > 0) :\n    LipschitzWith l f' := by\n  rw [lipschitzWith_iff_norm_sub_le]\n  intro x y\n  have H₁ : (1 / l * ‖f' x - f' y‖) * ‖f' x - f' y‖ ≤ (1 / l * ‖f' x - f' y‖) * (l * ‖x - y‖) := by\n    calc\n      _ = 1 / l * ‖f' x - f' y‖ ^ 2 := by\n        simp\n        rw [mul_assoc, ← pow_two (‖f' x - f' y‖)]\n      _ ≤ ‖f' x - f' y‖ * ‖x - y‖ := by\n        apply le_trans (h₂ x y)\n        apply real_inner_le_norm\n      _ = (1 / l * ‖f' x - f' y‖) * (l * ‖x - y‖) := by\n        field_simp\n        ring_nf\n  have H₂ : 1 / l > 0 := by apply one_div_pos.mpr hl\n  cases lt_or_ge 0 (‖f' x - f' y‖)\n  case inl h =>\n    apply le_of_mul_le_mul_left H₁\n    apply mul_pos _ h\n    · simp [H₂, hl]\n  case inr h =>\n    apply le_trans h\n    apply mul_nonneg\n    · simp [hl]\n    apply norm_nonneg _",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "lipschitz_continuos_upper_bound'",
        "theorem_statement": " (h₁ : ∀ x₁ : E, HasGradientAt f (f' x₁) x₁) (h₂ : LipschitzWith l f') :\n  ∀ x y : E, f y ≤ f x + inner (f' x) (y - x) + l / 2 * ‖y - x‖ ^ 2",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable [CompleteSpace E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {xm : E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lipschitz_continuos_upper_bound' (h₁ : ∀ x₁ : E, HasGradientAt f (f' x₁) x₁) (h₂ : LipschitzWith l f') :\n    ∀ x y : E, f y ≤ f x + inner (f' x) (y - x) + l / 2 * ‖y - x‖ ^ 2 :=\n  by\n  intro x y\n  rw [lipschitzWith_iff_norm_sub_le] at h₂\n  let g := fun x ↦ (toDual ℝ E) (f' x)\n  have h' : ∀ x : E, HasFDerivAt f (g x) x := h₁\n  have equiv : ∀ x y : E, inner (f' x) (y - x) = (g x) (y - x) :=\n    by\n    intro x y\n    rw [InnerProductSpace.toDual_apply]\n  have h₂' : LipschitzWith l g := by\n    simp only [g, equiv]\n    rw [lipschitzWith_iff_norm_sub_le]\n    intro x y\n    have h1 : ∀ x : E, ‖(toDual ℝ E) x‖ = ‖x‖ := by simp [LinearIsometryEquiv.norm_map]\n    have : ‖(toDual ℝ E) (f' x) - (toDual ℝ E) (f' y)‖ = ‖f' x - f' y‖ :=\n      by\n      rw [← map_sub (toDual ℝ E) (f' x) (f' y)]\n      exact h1 (f' x - f' y)\n    rw [this]\n    exact h₂ x y\n  rw [equiv]\n  exact lipschitz_continuous_upper_bound h' h₂' x y",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "lipschitz_minima_lower_bound",
        "theorem_statement": " (h₁ : ∀ x : E, HasGradientAt f (f' x) x) (h₂ : LipschitzWith l f') (min : IsMinOn f Set.univ xm) (hl : l > 0) :\n  ∀ x : E, 1 / (2 * l) * ‖f' x‖ ^ 2 ≤ f x - f xm",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable [CompleteSpace E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {xm : E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "InnerProductSpace",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lipschitz_minima_lower_bound (h₁ : ∀ x : E, HasGradientAt f (f' x) x) (h₂ : LipschitzWith l f')\n    (min : IsMinOn f Set.univ xm) (hl : l > 0) : ∀ x : E, 1 / (2 * l) * ‖f' x‖ ^ 2 ≤ f x - f xm :=\n  by\n  intro x\n  rw [IsMinOn, IsMinFilter] at min\n  simp at min\n  let y : E := x - ((1 : ℝ) / l : ℝ) • (f' x)\n  have eq : f xm ≤ f x - 1 / (2 * l) * ‖f' x‖ ^ 2 := by\n    calc\n      _ ≤ f y := by apply min\n      _ ≤ f x + inner (f' x) (y - x) + l / 2 * ‖y - x‖ ^ 2 := by apply lipschitz_continuos_upper_bound' h₁ h₂\n      _ = f x - 1 / (2 * l) * ‖f' x‖ ^ 2 := by\n        rw [add_assoc]; rw [sub_eq_add_neg (f x), add_left_cancel_iff.2]\n        field_simp [y]; rw [← real_inner_self_eq_norm_sq, ← real_inner_self_eq_norm_sq]\n        rw [inner_smul_right, inner_smul_left, inner_smul_right]\n        field_simp; ring_nf\n  linarith",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "lipschitz_to_lnorm_sub_convex",
        "theorem_statement": " (hs : Convex ℝ s) (h₁ : ∀ x ∈ s, HasGradientAt f (f' x) x) (h₂ : LipschitzOnWith l f' s) (hl : l > 0) :\n  ConvexOn ℝ s (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable [CompleteSpace E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {xm : E}",
            "variable {x y : E}",
            "variable {s v : Set E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lipschitz_to_lnorm_sub_convex (hs : Convex ℝ s) (h₁ : ∀ x ∈ s, HasGradientAt f (f' x) x)\n    (h₂ : LipschitzOnWith l f' s) (hl : l > 0) : ConvexOn ℝ s (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x) :=\n  by\n  rw [lipschitzOnWith_iff_norm_sub_le] at h₂\n  let g' : E → E := fun x ↦ l.1 • x - f' x\n  have H₂ : ∀ x ∈ s, ∀ y ∈ s, inner (g' x - g' y) (x - y) ≥ (0 : ℝ) :=\n    by\n    intro x hx y hy\n    calc\n      _ = l.1 * (inner (x - y) (x - y)) - inner (f' x - f' y) (x - y) :=\n        by\n        simp [g']\n        rw [← sub_add, sub_right_comm, sub_add, inner_sub_left, ← smul_sub, inner_smul_left]\n        simp only [conj_trivial]\n      _ = l * ‖x - y‖ ^ 2 - inner (f' x - f' y) (x - y) := by\n        simp; left\n        apply real_inner_self_eq_norm_sq\n      _ ≥ l * ‖x - y‖ ^ 2 - ‖f' x - f' y‖ * ‖x - y‖ :=\n        by\n        apply add_le_add; linarith\n        simp\n        apply real_inner_le_norm\n      _ ≥ l * ‖x - y‖ ^ 2 - l * ‖x - y‖ ^ 2 := by\n        simp\n        rw [pow_two, ← mul_assoc]\n        apply mul_le_mul (h₂ hx hy); linarith; apply norm_nonneg\n        apply mul_nonneg _ (norm_nonneg _)\n        simp [hl]\n      _ = 0 := by simp\n  have H₃ : ∀ x ∈ s, HasGradientAt (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x) (g' x) x :=\n    by\n    intro x hx\n    have u₂ := HasGradientAt.const_smul (gradient_norm_sq_eq_two_self x) ((l / (2 : ℝ)) : ℝ)\n    have u := u₂.add (HasGradientAt.neg (h₁ x hx))\n    have l₁ : (fun x ↦ l / 2 * ‖x‖ ^ 2 + -f x) = (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x) := by ext; ring\n    have l₂ : (l.1 / 2) • (2 : ℝ) • x + -f' x = g' x := by simp [g']; rw [smul_smul, ← sub_eq_add_neg]; ring_nf\n    rw [← l₁, ← l₂]\n    apply u\n  apply monotone_gradient_convex' hs\n  apply H₃\n  intro x hx y hy\n  exact H₂ x hx y hy",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "convex_to_lower",
        "theorem_statement": " {l : ℝ} (h₁ : ∀ x : E, HasGradientAt f (f' x) x) (h₂ : ConvexOn ℝ Set.univ (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x))\n  (lp : l > 0) (hfun : ConvexOn ℝ Set.univ f) (x : E) (y : E) : inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable [CompleteSpace E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {xm : E}",
            "variable {x y : E}",
            "variable {s v : Set E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem convex_to_lower {l : ℝ} (h₁ : ∀ x : E, HasGradientAt f (f' x) x)\n    (h₂ : ConvexOn ℝ Set.univ (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x)) (lp : l > 0) (hfun : ConvexOn ℝ Set.univ f) (x : E)\n    (y : E) : inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2 :=\n  by\n  rw [ConvexOn] at hfun\n  let fs : E → (E → ℝ) := fun s => (fun x => f x - inner (f' s) x)\n  have hfunconvex : ∀ s : E, ConvexOn ℝ Set.univ (fs s) :=\n    by\n    intro s\n    rw [ConvexOn]\n    simp\n    constructor\n    · apply hfun.1\n    · intro x₁ y₁ a b ha hb hab\n      have : f (a • x₁ + b • y₁) ≤ a * f x₁ + b * f y₁ :=\n        by\n        apply hfun.2 _ _ ha hb hab\n        simp; simp\n      simp [fs]\n      apply le_trans this\n      apply Eq.ge; ring_nf\n      rw [inner_add_right, real_inner_smul_right, real_inner_smul_right]; ring\n  let fs' : E → (E → E) := fun s => (fun z ↦ f' z - f' s)\n  have hfconx₁ : ∀ s x : E, HasGradientAt (fs s) (fs' s x) x :=\n    by\n    intro s z\n    apply HasGradientAt.sub\n    · rcases h₁ z with _\n      apply h₁\n    · apply gradient_of_inner_const z (f' s)\n  have hfy₁ : ∀ x : E, HasGradientAt (fs y) (fs' y x) x := hfconx₁ y\n  have hfx₁ : ∀ x₁ : E, HasGradientAt (fs x) (fs' x x₁) x₁ := hfconx₁ x\n  rw [ConvexOn] at h₂\n  let gs : E → (E → ℝ) := fun s ↦ (fun z ↦ l / 2 * ‖z‖ ^ 2 - (fs s) z)\n  have hgxconvex : ∀ s : E, ConvexOn ℝ Set.univ (gs s) :=\n    by\n    intro s; rw [ConvexOn]\n    constructor\n    · apply hfun.1\n    · intro x₁ hhx₁ y₁ hhy₁ a b ha hb hab\n      have h₂' :\n        l / 2 * ‖a • x₁ + b • y₁‖ ^ 2 - f (a • x₁ + b • y₁) ≤\n          a • (l / 2 * ‖x₁‖ ^ 2 - f x₁) + b • (l / 2 * ‖y₁‖ ^ 2 - f y₁) :=\n        by apply h₂.2 hhx₁ hhy₁ ha hb hab\n      simp only [smul_eq_mul, gs, fs]\n      rw [inner_add_right, real_inner_smul_right, real_inner_smul_right]\n      calc\n        _ = (l / 2) * ‖a • x₁ + b • y₁‖ ^ 2 - f (a • x₁ + b • y₁) + (a * inner (f' s) x₁ + b * inner (f' s) y₁) := by\n          ring_nf\n        _ ≤\n            a • (l / 2 * ‖x₁‖ ^ 2 - f x₁) + b • (l / 2 * ‖y₁‖ ^ 2 - f y₁) +\n              (a * inner (f' s) x₁ + b * inner (f' s) y₁) :=\n          by apply add_le_add_right h₂'\n        _ = a • (l / 2 * ‖x₁‖ ^ 2 - (f x₁ - inner (f' s) x₁)) + b • (l / 2 * ‖y₁‖ ^ 2 - (f y₁ - inner (f' s) y₁)) := by\n          simp; ring_nf\n  let gs' := fun s ↦ (fun z ↦ l • z - (fs' s z))\n  have hgx₁ : ∀ s x : E, HasGradientAt (gs s) ((gs' s) x) x :=\n    by\n    intro s z\n    apply HasGradientAt.sub (gradient_of_const_mul_norm l z) (hfconx₁ s z)\n  have hgx₂ : ∀ s z₁ z₂ : E, (gs s) z₁ + inner (gs' s z₁) (z₂ - z₁) ≤ gs s z₂ :=\n    by\n    intro s z₁ z₂\n    apply Convex_first_order_condition' (hgx₁ s z₁) (hgxconvex s)\n    · simp only [Set.mem_univ]\n    · simp only [Set.mem_univ]\n  have hfx₂ : ∀ (s x y₁ : E), (fs s) y₁ ≤ fs s x + inner (fs' s x) (y₁ - x) + l / 2 * ‖y₁ - x‖ ^ 2 :=\n    by\n    intro s z₁ z₂\n    simp only [fs, fs']\n    rcases hgx₂ s z₁ z₂ with hgx₂'\n    have t₇ : gs s z₁ = l / 2 * ‖z₁‖ ^ 2 - fs s z₁ := by rfl\n    have t₈ : gs s z₂ = l / 2 * ‖z₂‖ ^ 2 - fs s z₂ := by rfl\n    have t₉ : gs' s z₁ = l • z₁ - fs' s z₁ := by rfl\n    rw [t₇, t₈, t₉] at hgx₂'\n    have t₁₀ : fs s z₂ + (l / 2 * ‖z₁‖ ^ 2 - fs s z₁ + inner (l • z₁ - fs' s z₁) (z₂ - z₁)) ≤ l / 2 * ‖z₂‖ ^ 2 := by\n      apply add_le_of_le_sub_left hgx₂'\n    have t₁₁ : fs s z₂ ≤ l / 2 * ‖z₂‖ ^ 2 - (l / 2 * ‖z₁‖ ^ 2 - fs s z₁ + inner (l • z₁ - fs' s z₁) (z₂ - z₁)) :=\n      by\n      rw [add_comm] at t₁₀\n      apply le_sub_left_of_add_le t₁₀\n    simp only [] at t₁₁; rw [← sub_add (l / 2 * ‖z₁‖ ^ 2) _ _] at t₁₁\n    calc\n      _ ≤ l / 2 * ‖z₂‖ ^ 2 - (l / 2 * ‖z₁‖ ^ 2 - f z₁ + inner (f' s) z₁ + inner (l • z₁ - fs' s z₁) (z₂ - z₁)) := by\n        apply t₁₁\n      _ =\n          l / 2 * ‖z₂‖ ^ 2 -\n            (l / 2 * ‖z₁‖ ^ 2 - f z₁ + inner (f' s) z₁ +\n              (l * (inner z₁ z₂ - ‖z₁‖ ^ 2) - inner (f' z₁ - f' s) (z₂ - z₁))) :=\n        by\n        rw [inner_sub_left, inner_smul_left]\n        simp; rw [inner_sub_right, real_inner_self_eq_norm_sq]; left; simp\n      _ = f z₁ - inner (f' s) z₁ + inner (f' z₁ - f' s) (z₂ - z₁) + l / 2 * (‖z₂‖ ^ 2 - 2 * inner z₂ z₁ + ‖z₁‖ ^ 2) :=\n        by field_simp; ring_nf; rw [real_inner_comm]\n      _ = f z₁ - inner (f' s) z₁ + inner (f' z₁ - f' s) (z₂ - z₁) + l / 2 * ‖z₂ - z₁‖ ^ 2 := by rw [← norm_sub_sq_real]\n  have hfs₃ : ∀ s : E, IsMinOn (fs s) univ s := by\n    intro s\n    apply first_order_convex (hfconx₁ s) (hfunconvex s)\n    simp only [fs, fs', sub_self]\n  have hfy₃ : IsMinOn (fs y) _ y := hfs₃ y\n  have hfx₄ : fs x x ≤ fs x y - 1 / (2 * l) * ‖fs' x y‖ ^ 2 :=\n    by\n    have : fs x x ≤ fs x (y - (1 / l) • fs' x y) :=\n      by\n      rcases hfs₃ x with hf3'\n      rw [isMinOn_iff] at hf3'\n      apply hf3'\n      simp\n    apply le_trans this\n    rcases hfx₂ x y (y - (1 / l) • fs' x y) with hfx₂'\n    calc\n      _ ≤ fs x y + inner (fs' x y) (y - (1 / l) • fs' x y - y) + l / 2 * ‖y - (1 / l) • fs' x y - y‖ ^ 2 := by\n        apply hfx₂'\n      _ = fs x y - 1 / (2 * l) * ‖fs' x y‖ ^ 2 :=\n        by\n        have : y - (1 / l) • fs' x y - y = -(1 / l) • fs' x y := by simp\n        rw [this, real_inner_smul_right]\n        repeat rw [← real_inner_self_eq_norm_sq, ← real_inner_self_eq_norm_sq]\n        rw [real_inner_smul_right, real_inner_smul_left]; field_simp; ring\n  have hfy₄ : fs y y ≤ fs y x - 1 / (2 * l) * ‖fs' y x‖ ^ 2 :=\n    by\n    have : fs y y ≤ fs y (x - (1 / l) • fs' y x) :=\n      by\n      rw [isMinOn_iff] at hfy₃\n      rcases hfy₃ (x - (1 / l) • fs' y x) with hfy₃'\n      apply hfy₃'\n      simp\n    apply le_trans this\n    rcases hfx₂ y x (x - (1 / l) • fs' y x) with hfy₂'\n    calc\n      _ ≤ fs y x + inner (fs' y x) (x - (1 / l) • fs' y x - x) + l / 2 * ‖x - (1 / l) • fs' y x - x‖ ^ 2 := by\n        apply hfy₂'\n      _ = fs y x - 1 / (2 * l) * ‖fs' y x‖ ^ 2 :=\n        by\n        have : x - (1 / l) • fs' y x - x = -(1 / l) • fs' y x := by simp\n        rw [this, real_inner_smul_right]\n        rw [← real_inner_self_eq_norm_sq, ← real_inner_self_eq_norm_sq, real_inner_smul_right]\n        rw [real_inner_smul_left]; field_simp; ring\n  have hh₁ : (1 / (2 * l)) * ‖f' x - f' y‖ ^ 2 ≤ f y - f x - inner (f' x) (y - x) := by\n    calc\n      (1 / (2 * l)) * ‖f' x - f' y‖ ^ 2 ≤ fs x y - fs x x :=\n        by\n        have : f' x - f' y = -fs' x y := by\n          have : fs' x y = f' y - f' x := by rfl\n          rw [this]; simp\n        rw [this]\n        have : ‖-fs' x y‖ = ‖fs' x y‖ := by apply norm_neg\n        rw [this]\n        linarith [hfx₄]\n      _ = f y - f x - inner (f' x) (y - x) :=\n        by\n        have t₄ : fs x y = f y - inner (f' x) y := by rfl\n        have t₅ : fs x x = f x - inner (f' x) x := by rfl\n        rw [t₄, t₅, inner_sub_right]\n        ring\n  have hh₂ : (1 / (2 * l)) * ‖f' x - f' y‖ ^ 2 ≤ f x - f y - inner (f' y) (x - y) := by\n    calc\n      (1 / (2 * l)) * ‖f' x - f' y‖ ^ 2 ≤ fs y x - fs y y :=\n        by\n        have : f' x - f' y = fs' y x := by simp\n        rw [this]\n        linarith [hfy₄]\n      _ = f x - f y - inner (f' y) (x - y) :=\n        by\n        have t₄' : fs y y = f y - inner (f' y) y := by rfl\n        have t₅' : fs y x = f x - inner (f' y) x := by rfl\n        rw [t₄', t₅', inner_sub_right]\n        ring\n  calc\n    _ = (1 / (2 * l)) * ‖f' x - f' y‖ ^ 2 + (1 / (2 * l)) * ‖f' x - f' y‖ ^ 2 :=\n      by\n      field_simp\n      rw [← mul_two, mul_comm]\n      ring\n    _ ≤ (f y - f x - inner (f' x) (y - x)) + (f x - f y - inner (f' y) (x - y)) := by apply add_le_add hh₁ hh₂\n    _ = inner (f' x - f' y) (x - y) := by\n      rw [inner_sub_left]\n      have t₆ : (inner (f' x) (y - x) : ℝ) = -(inner (f' x) (x - y) : ℝ) := by rw [inner_sub_right, inner_sub_right];\n        ring\n      rw [t₆]; ring",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "lipschitz_to_lower",
        "theorem_statement": " (h₁ : ∀ x, HasGradientAt f (f' x) x) (h₂ : LipschitzWith l f') (hfun : ConvexOn ℝ Set.univ f) (hl : l > 0) :\n  ∀ x y, inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable [CompleteSpace E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {xm : E}",
            "variable {x y : E}",
            "variable {s v : Set E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lipschitz_to_lower (h₁ : ∀ x, HasGradientAt f (f' x) x) (h₂ : LipschitzWith l f') (hfun : ConvexOn ℝ Set.univ f)\n    (hl : l > 0) : ∀ x y, inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2 :=\n  by\n  obtain convex : ConvexOn ℝ Set.univ (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x) :=\n    lipschitz_to_lnorm_sub_convex convex_univ (fun x _ => h₁ x) (lipschitzOnWith_univ.mpr h₂) hl\n  exact convex_to_lower h₁ convex hl hfun",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "lower_iff_lipschitz",
        "theorem_statement": " (h₁ : ∀ x, HasGradientAt f (f' x) x) (hfun : ConvexOn ℝ Set.univ f) (hl : l > 0) :\n  LipschitzWith l f' ↔ ∀ x y, inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable [CompleteSpace E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {xm : E}",
            "variable {x y : E}",
            "variable {s v : Set E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lower_iff_lipschitz (h₁ : ∀ x, HasGradientAt f (f' x) x) (hfun : ConvexOn ℝ Set.univ f) (hl : l > 0) :\n    LipschitzWith l f' ↔ ∀ x y, inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2 :=\n  ⟨fun h ↦ lipschitz_to_lower h₁ h hfun hl, fun h ↦ lower_to_lipschitz h hl⟩",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "lipshictz_iff_lnorm_sub_convex",
        "theorem_statement": " (h₁ : ∀ x, HasGradientAt f (f' x) x) (hfun : ConvexOn ℝ Set.univ f) (hl : l > 0) :\n  LipschitzWith l f' ↔ ConvexOn ℝ univ (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x)",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable [CompleteSpace E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {xm : E}",
            "variable {x y : E}",
            "variable {s v : Set E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lipshictz_iff_lnorm_sub_convex (h₁ : ∀ x, HasGradientAt f (f' x) x) (hfun : ConvexOn ℝ Set.univ f)\n    (hl : l > 0) : LipschitzWith l f' ↔ ConvexOn ℝ univ (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x) :=\n  by\n  constructor\n  · intro h\n    exact lipschitz_to_lnorm_sub_convex convex_univ (fun x _ ↦ h₁ x) (fun x _ y _ => h x y) hl\n  intro h'\n  rw [lower_iff_lipschitz h₁ hfun hl]\n  exact fun x y => convex_to_lower h₁ h' hl hfun x y",
        "type": "theorem",
        "filename": "Lsmooth"
    },
    {
        "theorem_name": "lower_iff_lnorm_sub_convex",
        "theorem_statement": " (h₁ : ∀ x, HasGradientAt f (f' x) x) (hfun : ConvexOn ℝ Set.univ f) (hl : l > 0) :\n  ConvexOn ℝ univ (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x) ↔ ∀ x y, inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2",
        "variable": [
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [NormedSpace ℝ E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → (E →L[ℝ] ℝ)}",
            "variable {f'' : E → E →L[ℝ] E →L[ℝ] ℝ}",
            "variable {l : NNReal}",
            "variable {E : Type*}",
            "variable [NormedAddCommGroup E]",
            "variable [InnerProductSpace ℝ E]",
            "variable [CompleteSpace E]",
            "variable {f : E → ℝ}",
            "variable {a : ℝ}",
            "variable {f' : E → E}",
            "variable {xm : E}",
            "variable {x y : E}",
            "variable {s v : Set E}",
            "variable {l : NNReal}"
        ],
        "namespaces": [
            "Set",
            "Set",
            "InnerProductSpace"
        ],
        "proof_process": "theorem lower_iff_lnorm_sub_convex (h₁ : ∀ x, HasGradientAt f (f' x) x) (hfun : ConvexOn ℝ Set.univ f) (hl : l > 0) :\n    ConvexOn ℝ univ (fun x ↦ l / 2 * ‖x‖ ^ 2 - f x) ↔ ∀ x y, inner (f' x - f' y) (x - y) ≥ 1 / l * ‖f' x - f' y‖ ^ 2 :=\n  by\n  rw [← lipshictz_iff_lnorm_sub_convex h₁ hfun hl]\n  rw [lower_iff_lipschitz h₁ hfun hl]",
        "type": "theorem",
        "filename": "Lsmooth"
    }
]